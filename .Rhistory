# Draw the hair
polygon(x=c(3,5,7,7,5,3), y=c(9,9,8,7,6,6), density=20, col="black")
# Add a label
text(5,9.5, "Lemmy Kilmister", cex=1.5, col="black")
}
draw_lemmy()
draw_lemmy()
draw_lemmy()
draw_lemmy <- function() {
# Set the canvas size
plot(1,1, xlim=c(0,10), ylim=c(0,10), type="n", ann=FALSE)
# Draw the head
polygon(x=c(4,6,6,4), y=c(7,7,9,9), density=20, col="lightgrey")
# Draw the eyes
points(4,8.5, pch=1, cex=1, col="black")
points(6,8.5, pch=1, cex=1, col="black")
# Draw the nose
points(5,8, pch=3, cex=1, col="black")
# Draw the mouth
lines(c(4.5, 5.5), c(7.5, 7.5), lwd=2, col="black")
# Draw the mustache
lines(c(4.5, 5.5), c(7, 7), lwd=2, col="black")
lines(c(5.5, 6.5), c(7, 7), lwd=2, col="black")
# Draw the cigarette
lines(c(4.8, 5.2), c(7.2, 7.2), lwd=1, col="red")
points(5,7.2, pch=20, cex=0.5, col="red")
# Draw the hair
polygon(x=c(3,5,7,7,5,3), y=c(9,9,8,7,6,6), density=20, col="black")
# Add a label
text(5,9.5, "Lemmy Kilmister", cex=1.5, col="black")
}
draw_lemmy()
play_alle_meine_entchen <- function() {
library(tuneR)
# Define the notes and durations of the song
notes <- c(72, 71, 72, 72, 74, 74, 74, 76, 77, 77, 77, 77,
77, 75, 75, 75, 75, 75, 73, 73, 73, 73, 72, 72, 72, 72, 72, 71, 71, 71, 71, 71,
72, 72, 72, 72, 74, 74, 74, 76, 77, 77, 77, 77, 77, 75, 75, 75, 75, 75, 73, 73, 73, 73, 72, 72, 72, 72, 72)
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)
# Play the song
play(notes, durations, 1)
}
play_alle_meine_entchen()
install.packages("tuneR")
play_alle_meine_entchen()
?play
playAlleMeineEntchen <- function() {
library(tuneR)
# Define the notes and durations for the tune
notes <- c("C5", "C5", "D5", "C5", "F5", "E5", "C5", "C5", "D5", "C5", "G5", "F5",
"C5", "C5", "C6", "A5", "F5", "E5", "D5", "B4", "B4", "C5", "A4", "F4", "D4")
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
# Play the tune
play(notes, durations)
}
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(tuneR)
# Define the notes and durations for the tune
notes <- c("C5", "C5", "D5", "C5", "F5", "E5", "C5", "C5", "D5", "C5", "G5", "F5",
"C5", "C5", "C6", "A5", "F5", "E5", "D5", "B4", "B4", "C5", "A4", "F4", "D4")
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
# Convert the notes to a melody object
melody <- noteSeq(notes, durations)
# Play the tune
soundsc(melody, sampling=11025, sound=NULL, l=NULL)
}
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(tuneR)
# Define the notes and durations for the tune
notes <- c("C5", "C5", "D5", "C5", "F5", "E5", "C5", "C5", "D5", "C5", "G5", "F5",
"C5", "C5", "C6", "A5", "F5", "E5", "D5", "B4", "B4", "C5", "A4", "F4", "D4")
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
# Convert the notes to a melody object
melody <- rep(NA, length(notes))
for (i in 1:length(notes)) {
melody[i] <- note(notes[i], durations[i])
}
# Play the tune
soundsc(melody, sampling=11025, sound=NULL, l=NULL)
}
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(tuneR)
# Define the notes and durations for the tune
notes <- c("C5", "C5", "D5", "C5", "F5", "E5", "C5", "C5", "D5", "C5", "G5", "F5",
"C5", "C5", "C6", "A5", "F5", "E5", "D5", "B4", "B4", "C5", "A4", "F4", "D4")
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
# Convert the notes to a melody object
melody <- seq(notes, durations)
# Play the tune
soundsc(melody, sampling=11025, sound=NULL, l=NULL)
}
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(tuneR)
# Define the notes and durations for the tune
notes <- c("C5", "C5", "D5", "C5", "F5", "E5", "C5", "C5", "D5", "C5", "G5", "F5",
"C5", "C5", "C6", "A5", "F5", "E5", "D5", "B4", "B4", "C5", "A4", "F4", "D4")
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
# Convert the notes to a melody object
melody <- tune(notes, durations)
# Play the tune
soundsc(melody, sampling=11025, sound=NULL, l=NULL)
}
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(tuneR)
# Define the notes and durations for the tune
notes <- c("C5", "C5", "D5", "C5", "F5", "E5", "C5", "C5", "D5", "C5", "G5", "F5",
"C5", "C5", "C6", "A5", "F5", "E5", "D5", "B4", "B4", "C5", "A4", "F4", "D4")
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
# Convert the notes to a melody object
melody <- rep(NA, length(notes))
for (i in 1:length(notes)) {
melody[i] <- note(notes[i], durations[i])
}
# Play the tune
soundsc(melody, sampling=11025, sound=NULL, l=NULL)
}
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(Rmusic)
# Define the notes and durations for the tune
notes <- c("C5", "C5", "D5", "C5", "F5", "E5", "C5", "C5", "D5", "C5", "G5", "F5",
"C5", "C5", "C6", "A5", "F5", "E5", "D5", "B4", "B4", "C5", "A4", "F4", "D4")
durations <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
# Convert the notes to a melody object
melody <- rep(NA, length(notes))
for (i in 1:length(notes)) {
melody[i] <- note(notes[i], durations[i])
}
# Play the tune
play(melody)
}
pla
playAlleMeineEntchen()
install.packages("Rmusic")
devtools::install_github("keithmcnulty/Rmusic", build_vignettes = TRUE)
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(tuneR)
# Load the MIDI file
midi <- readMIDI("D:/alle_meine_entchen.mid")
# Play the MIDI file
play(midi)
}
playAlleMeineEntchen()
playAlleMeineEntchen <- function() {
library(tuneR)
# Load the MIDI file
midi <- readMidi("D:/alle_meine_entchen.mid")
# Play the MIDI file
play(midi)
}
playAlleMeineEntchen()
# Load the MIDI file
midi <- readMIDI("D:/alle_meine_entchen.mid")
# Load the MIDI file
midi <- readMidi("D:/alle_meine_entchen.mid")
class(midi)
midi
playAlleMeineEntchen <- function() {
library(tuneR)
# Load the MIDI file
midi <- readMidi("D:/alle_meine_entchen.mid")
# Play the MIDI file
play(midi)
}
library(ggplot2)
draw_rose <- function(n_petals = 8, center = c(0,0),
radius = 1, start_angle = 0) {
angles <- seq(start_angle, 360 + start_angle, length.out = n_petals*2 + 1)
df <- data.frame(angle = angles, radius = c(rep(radius, n_petals),
rep(radius/2, n_petals)))
df$x <- df$radius * cos(df$angle * pi/180) + center[1]
df$y <- df$radius * sin(df$angle * pi/180) + center[2]
ggplot() +
geom_path(data = df, aes(x = x, y = y)) +
coord_fixed()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2, start_angle = 45)
library(ggplot2)
draw_rose <- function(n_petals = 8, center = c(0,0),
radius = 1, start_angle = 0) {
angles <- seq(start_angle, 360 + start_angle, length.out = n_petals*2 + 1)
df <- data.frame(angle = angles, radius = c(rep(radius, n_petals),
rep(radius/2, n_petals)))
df$x <- df$radius * cos(df$angle * pi/180) + center[1]
df$y <- df$radius * sin(df$angle * pi/180) + center[2]
ggplot() +
geom_path(data = df, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2, start_angle = 45)
draw_rose <- function(n_petals = 8, center = c(0,0),
radius = 1, start_angle = 0) {
angles <- seq(start_angle, 360 + start_angle, length.out = n_petals*2)
df <- data.frame(angle = angles, radius = c(rep(radius, n_petals),
rep(radius/2, n_petals)))
df$x <- df$radius * cos(df$angle * pi/180) + center[1]
df$y <- df$radius * sin(df$angle * pi/180) + center[2]
ggplot() +
geom_path(data = df, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2, start_angle = 45)
draw_rose(n_petals = 16, center = c(1,1), radius = 2, start_angle = 45)
draw_rose(n_petals = 16, center = c(1,1), radius = 2, start_angle = 45)
draw_rose(n_petals = 10, center = c(1,1), radius = 2, start_angle = 45)
draw_rose(n_petals = 4, center = c(1,1), radius = 2, start_angle = 45)
draw_rose <- function(n_petals = 8, center = c(0,0), radius = 1) {
angles <- seq(0, 360, length.out = n_petals + 1)
x <- radius * cos(angles * pi/180) + center[1]
y <- radius * sin(angles * pi/180) + center[2]
data <- data.frame(x, y)
ggplot() +
geom_path(data = data, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2)
draw_rose <- function(n_petals = 8, center = c(0,0), radius = 1) {
angles <- seq(0, 360, length.out = n_petals + 1)
x <- radius * cos(angles * pi/180) + center[1]
y <- radius * sin(angles * pi/180) + center[2]
data <- data.frame(x, y)
ggplot() +
geom_path(data = data, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2)
draw_rose(n_petals = 10, center = c(1,1), radius = 2)
draw_rose(n_petals = 4, center = c(1,1), radius = 2)
draw_rose(n_petals = 160, center = c(1,1), radius = 2)
draw_rose <- function(n_petals = 8, center = c(0,0), radius = 1) {
angles <- seq(0, 360, length.out = n_petals + 1)
radii <- c(rep(radius, n_petals), radius/2)
df <- data.frame(angle = angles, radius = radii)
df$x <- df$radius * cos(df$angle * pi/180) + center[1]
df$y <- df$radius * sin(df$angle * pi/180) + center[2]
ggplot() +
geom_path(data = df, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose <- function(n_petals = 8, center = c(0,0), radius = 1) {
angles <- seq(0, 360, length.out = n_petals + 1)
radii <- c(rep(radius, n_petals), radius/2)
df <- data.frame(angle = angles, radius = radii)
df$x <- df$radius * cos(df$angle * pi/180) + center[1]
df$y <- df$radius * sin(df$angle * pi/180) + center[2]
ggplot() +
geom_path(data = df, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2)
draw_rose <- function(n_petals = 8, center = c(0,0), radius = 1) {
angles <- seq(0, 360, length.out = n_petals + 1)
radii <- c(rep(radius, n_petals), radius/2)
df <- data.frame(angle = angles, radius = radii)
df$x <- df$radius * cos(df$angle * pi/180) + center[1]
df$y <- df$radius * sin(df$angle * pi/180) + center[2]
ggplot() +
geom_path(data = df, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2)
nchar("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
setwd("D:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
source("./simulations/hierpr/functions.R")
if (FALSE) {
# Generate the tree structure:
# Keep generating new tree structures until a tree structure
# with exactly 50 leaf nodes results:
nleaf <- 0
count <- 0
set.seed(12)
while(nleaf!=50) {
tempobj <- gen_tree_structure(50)
nleaf <- tempobj$rightnodes[length(tempobj$rightnodes)] - tempobj$leftnodes[length(tempobj$leftnodes)] + 1
count <- count + 1
}
count
treestruc <- tempobj
plot_structure(treestruc)
save(treestruc, file="./simulations/hierpr/results/intermediate_results/treestruc.Rda")
sum(sapply(1:length(treestruc$leftnodes), function(x) treestruc$rightnodes[x] - treestruc$leftnodes[x] + 1))
}
# -	Erster Schritt ist die hierarchische Baumstruktur festlegen.
# -	Jeder interne Knoten ist mit einem lokalen Modell verknüpft, wobei die Unterscheidbarkeit der Klassen geringer werden soll, je weiter unten man in der hierarchischen Struktur ankommt. Das wird realisiert in dem das Rauschen (epsilon) immer weiter vergrößert wird, je weiter man nach unten kommt.
# -	Dass die Koeffizienten von vertikal benachbarten Schichten sich ähnlich sind, wird so realisiert, dass die Koeffizenten aus Normalverteilungen mit Mittelwerten gleich den Koeffizienten der darüberliegenden Schichten gezogen werden.
# unterschiedlche intercept sind, wichtig, damit ungeliche klassengrößen entstehen.
# die intercept von benachbarten schichten sollen nicht voneinander abhängen, weil
# die degrees der klassenungleichheiten nicht voneinander abhägne sollen.
# n <- 50000
#
# # erster coefficent intercept, rest sind die beeinflussenden betas:
# vCoef1 = rep(0, 6)
# vCoef2 = rnorm(6)
# vCoef3 = rnorm(6)
#
# # sim_multinom <- function(n, coefs) {
#
# mX = cbind(rep(1, n), matrix(rnorm(n*5), n, 5))
#
# # vector of probabilities
# vProb = cbind(exp(mX%*%vCoef1), exp(mX%*%vCoef2), exp(mX%*%vCoef3))
#
# # multinomial draws
# mChoices = t(apply(vProb, 1, rmultinom, n = 1, size = 1))
# dfM = cbind.data.frame(y = apply(mChoices, 1, function(x) which(x==1)), mX)
#
# library("nnet")
# m <- multinom(y ~ ., data = dfM)
# summary(m)
#
# vCoef2
# vCoef3
50*20
50*50
# 1. coefficenten simulieren:
#
# 2. Daten simulieren
# 3. Daten testen:
# da brauch ich
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# Function to simulate the coefficients:
# Function input:
# treestruc: A list. The tree structure.
# sdbeta0: The standard deviation of the normal distribution from which
# the intercepts are drawn.
# sdbeta: The standard deviation of the normal distribution from which
# the coefficients are drawn. These depend on the layer of the tree because
# lower tree layers should feature less predictive signal.
# Function output:
# A list containing, for each internal node the coefs to be used in the
# simulation, the child nodes, the parent nodes, and the layer of each node.
simulate_coefs <- function(treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5))) {
# Make a list that will contain the simulated coefficients as well as
# information on the tree structure (specifying the position of the
# node in the trees):
coeflist <- vector(mode = "list", length = length(treestruc$nodelist))
# Add the information on the tree structure:
for(i in seq(along=coeflist)) {
coeflist[[i]] <- list()
# Add the information on the child nodes for each node:
coeflist[[i]]$childnodes <- treestruc$nodelist[[i]]
# Add the information on the parent nodes for each node:
coeflist[[i]]$parentnodes <- which(sapply(1:length(coeflist), function(x) i %in% coeflist[[x]]$childnodes))
# Add the layer of each node:
coeflist[[i]]$layer <- which(sapply(1:length(treestruc$leftnodes), function(x) (i >= treestruc$leftnodes[x]) & (i <= treestruc$rightnodes[x])))
}
# Simulate the coefficients:
for(i in seq(along=coeflist)) {
# If the node has only two child nodes, we need only one set of coefficients:
if(length(coeflist[[i]]$childnodes)==2) {
coefs <- matrix(nrow=1, ncol=6, data=c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
# If the node has three child nodes, we need two sets of coefficients:
if(length(coeflist[[i]]$childnodes)==3) {
coefs <- rbind(c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])),
c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
coeflist[[i]]$coefs <- coefs
}
return(coeflist)
}
# Function that takes the covariate matrix of the subset of observations
# contained in a node and the coefficients associated with that node
# to output the indices of the child nodes to which the observations
# get assigned to.
# Note that the assignments are performed according to a multinomial
# regression model.
# Function input:
# Xsub: The matrix of observations in the current node. Observations in
# rows and variables in columns.
# coefs: The matrix of coefficients associated with the current node.
# Function output:
# A vector that gives the index of the child node for each observation.
get_child_nodes <- function(Xsub, coefs) {
# Determine the (unstandardized) probabilities for each child node:
desmat <- cbind(1, Xsub)
if (nrow(coefs)==2)
vProb <- cbind(1, exp(desmat%*%coefs[1,]), exp(desmat%*%coefs[2,]))
else
vProb <- cbind(1, exp(desmat%*%coefs[1,]))
# Draw the child nodes based on the probabilities obtained in the
# first step:
mChoices <- t(apply(vProb, 1, rmultinom, n = 1, size = 1))
# Make a vector of the child node indices:
ys <- apply(mChoices, 1, function(x) which(x==1))
return(ys)
}
# Function to simulate the data:
# Function input:
# n: Number of observations to simulate.
# coeflist: Result of simulate_coefs. A list that the coefs to be used in the
# simulation as well as other information about the tree structure.
# Function output:
# A list containing the following:
# data: The simulated data.frame.
# coeflist: The input list 'coeflist' to which the simulated data associated
# with each node was added.
sim_data <- function(n, coeflist) {
# Simulate the covariate matrix:
X <- matrix(nrow=n, ncol=5, rnorm(n*5))
# Simulate the outcome:
maxlayer <- max(sapply(coeflist, function(x) x$layer))
# Outcome matrix with 5 columns, where the j-th column
# will contain the classes of the observations in the
# j-th layer:
outcomemat <- matrix(nrow=nrow(X), ncol=maxlayer)
# Assign the child node classes of the observations in the root node:
# Determine the child nodes of the root node:
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
# Assign these child node classes:
outcomemat[,1] <- tempclass
# Store the data associated with the node also in 'coeflist':
coeflist[[1]]$datanode <- data.frame(X)
coeflist[[1]]$datanode$y <- factor(tempclass)
# Assign the child node classes of the observations in all other subsequent nodes:
for(i in 2:length(coeflist)) {
# Determine the subset of observations that are in the i-th node:
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
# Determine the child nodes for this subset of observations:
tempclass <- coeflist[[i]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
# Assign these child nodes to the corresponding rows in 'outcomemat':
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
# Store the data associated with the node also in 'coeflist':
coeflist[[i]]$datanode <- data.frame(X[subs,])
coeflist[[i]]$datanode$y <- factor(tempclass)
}
# Bring the outcome into the format needed by 'hierclass':
ystring <- apply(outcomemat, 1, function(x) paste(x, collapse="."))
# Make the data.frame:
data <- data.frame(X)
data$y <- factor(ystring)
return(list(data=data, coeflist=coeflist))
}
# Function used to evaluate how well the simulated data
# works:
# Function input:
# data: simulated data as output by sim_data().
# ntrain: Number of observations used for training
#  (the rest is used for testing).
# Function output:
# A list containing the following:
# precs: A vector of length 5, where the j-th element is the precision at the j-th layer.
# precscond: A vector of length 5, where the j-th element is the 'conditional precision' at the j-th layer,
# meaning the number of observations correctly predicted at the j-th layer divided by the number
# of observations correctly predicted a the j-1-th layer.
eval_perm <- function(data, ntrain=round(nrow(data)*(2/3))) {
# Train the prediction rule on the training data and obtain predictions
# for the test data:
# Load the required packages:
library("mlr3")
library("hierclass")
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = data)
# Initialize the learner for the top-down classification rule:
learner = lrn("classif.topdown")
learner$train(task, row_ids = 1:ntrain)
predictions = learner$predict(task, row_ids = (ntrain+1):nrow(data))
# Data frame containing the true and predicted observations:
truthpred <- data.frame(truth=data[(ntrain+1):nrow(data),]$y, pred=predictions$response)
# Subset the above data frame to only contain the observations correctly predicted
# at the j-th layer:
truthpred1 <- truthpred[sapply(as.character(truthpred$truth), function(x) strsplit(x, split="\\.")[[1]][1])==
sapply(as.character(truthpred$pred), function(x) strsplit(x, split="\\.")[[1]][1]),]
truthpred2 <- truthpred[sapply(as.character(truthpred$truth), function(x) paste(strsplit(x, split="\\.")[[1]][1:2], collapse="."))==
sapply(as.character(truthpred$pred), function(x) paste(strsplit(x, split="\\.")[[1]][1:2], collapse=".")),]
truthpred3 <- truthpred[sapply(as.character(truthpred$truth), function(x) paste(strsplit(x, split="\\.")[[1]][1:3], collapse="."))==
sapply(as.character(truthpred$pred), function(x) paste(strsplit(x, split="\\.")[[1]][1:3], collapse=".")),]
truthpred4 <- truthpred[sapply(as.character(truthpred$truth), function(x) paste(strsplit(x, split="\\.")[[1]][1:4], collapse="."))==
sapply(as.character(truthpred$pred), function(x) paste(strsplit(x, split="\\.")[[1]][1:4], collapse=".")),]
truthpred5 <- truthpred[as.character(truthpred$truth)==as.character(truthpred$pred),]
# Calculate the precisions at the different layers:
precs <- c(nrow(truthpred1),
nrow(truthpred2),
nrow(truthpred3),
nrow(truthpred4),
nrow(truthpred5))/(nrow(data)-ntrain)
# Calculate the conditional precisions at the different layers:
precscond <- c(nrow(truthpred1)/(nrow(data)-ntrain),
nrow(truthpred2)/nrow(truthpred1),
nrow(truthpred3)/nrow(truthpred2),
nrow(truthpred4)/nrow(truthpred3),
nrow(truthpred5)/nrow(truthpred4))
return(list(precs=precs, precscond=precscond, ntrain=ntrain, ntest=nrow(data)-ntrain))
}
# Simulate 10 datasets of size n=1000 and evaluate their performance
# using eval_perm():
set.seed(1234)
res5_s <- list()
for(i in 1:10) {
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
dataobj <- sim_data(n=1000, coeflist=coeflist)
res5_s[[i]] <- eval_perm(data=dataobj$data)
cat(paste("Iteration: ", i), "\n")
}
