y <- matrix(rep(NA, length(x) * J), nrow = length(x))
wow <- c()
for (j in 1:J) { # for each monotherapy
Dose <- c(Dose, x)
Drug <- c(Drug, rep(j, length(x)))
for (dose in 1:length(x)) {
y[dose, j] <-
max(c_mono[j] + (d_mono[j] - c_mono[j]) / (1 + 10 ^ (b_mono[j] * (  # the LL4 function
log10(IC50_monotherapy[pat, j]) - log10(x[dose])
))) +
rnorm(1, 0, standard_error), # measurement error
0)
}
wow <- c(y[, j])
Ymono <- c(Ymono, wow)
}
patient <- c(patient, rep(pat, length(x) * J))
}
data_mono <- data.frame(patient, Drug, Dose, "y_mono" = round(Ymono, 10))
return(data_mono)
}
# Simulate dose-response data for combinations ####
# init_ranking is the order of priority for testing the combinations
# nb_well is a vector if the number of combinations that is tester per patient
Simulation_response_combination <-
function(init_ranking, # prior assumption about the ranking of combination from best to worst, before the begening of the trial
nb_pat, # number of patients in the study
nb_well, # vector(of length nb_pat) of the number of combination that is tested on each patient
b, # vector of shape parameters for each combination
c, # vector of lower asymptote for each combination
d, # vector of upper asymptote for each combination
IC50_combi, # array of individual IC50s of combinations : one line per patient and one column per combination
standard_error, # measurement/technical variability
x1) { # the dose values are the same for all drugs and combinations in our scenarios
Y <- c() # viability vector
patient <- c() # patient index vector
Combi <- c() # combination index vector
Dose <- c() # dose vector
x <- x1
for (pat in 1:nb_pat) { # for each patients
combi_testees_cross <- c(init_ranking[1:nb_well[pat]]) # nb_well combinations are tested in the order of priority of the assumed ranking before the begening of the trial
y <-
matrix(rep(NA, length(x) * nb_well[pat]), nrow = length(x))
coll = 0
for (i in as.numeric(combi_testees_cross)) { # for each tested combination
coll = coll + 1
Dose <- c(Dose, x)
for (dose in 1:length(x)) { # for each tested dose-level
y[dose, coll] <-
max(c[i] + (d[i] - c[i]) / (1 + 10 ^ (b[i] * (  # the LL4 function
log10(IC50_combi[pat, i]) - log10(x[dose])
))) +
rnorm(1, 0, standard_error),  # measurement error
0)
}
Combi <- c(Combi, rep(i, length(x)))
Y <- c(Y, y[, coll])
}
patient <- c(patient, rep(pat, length(x1) * nb_well[pat]))
}
donne <- data.frame(patient, Combi, Dose, "y" = round(Y,10))
return(donne)
}
standard_error <- 0.4 # technical variability
nb_combi <- 15 #  number of combination
J = 6 # number of drugs
# this data.frame is useful to know which combined drugs correspond to the each combination's index :
structure_combi <- data.frame(
"Combi" = c(seq(1, nb_combi, 1)),
"Foreground" = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5),
"Background" = c(2, 3, 4, 5, 6, 3, 4, 5, 6, 4, 5, 6, 5, 6, 6)
)
x1 <- c(0.001, 0.2012, 0.4014, 0.6016, 0.8018, 1.5, 2)
x2 <- c(0.001, 0.2012, 0.4014, 0.6016, 0.8018, 1.5, 2)
x3 <- c(0.001, 0.2012, 0.4014, 0.6016, 0.8018, 1.5, 2)
x4 <- c(0.001, 0.2012, 0.4014, 0.6016, 0.8018, 1.5, 2)
x5 <- c(0.001, 0.2012, 0.4014, 0.6016, 0.8018, 1.5, 2)
x6 <- c(0.001, 0.2012, 0.4014, 0.6016, 0.8018, 1.5, 2)
scenario = "ideal"
nb_pat= 25
sigmaIC50= 0.15
Nsimu = 5
ncores= 5
ranking0 <- c(seq(1, 15, 1))
# parameters to generate monotherapy responses
b_mono = -c(1, 1, 1, 1, 1, 1)
c_mono = c(0.1, 0.1, 0.1, 0.1, 0.1, 0.1)
d_mono = c(0.92, 0.92, 0.92, 0.92, 0.92, 0.92)
mu_IC50_monotherapy = c(0.6, 0.6, 0.6, 0.6, 0.6, 0.6)
sigma_IC50_monotherapy = c(rep(sigmaIC50, J))
# parameters to generate combination responses
b = -c(seq(0.85, 3.79, 0.21))
c =  c(seq(0.05, 0.19, 0.01))
d = c(seq(0.1, 0.94, 0.06))
mu_IC50_combi = c(seq(0.1, 0.94, 0.06))
sigma_IC50_combi <- c(rep(sigmaIC50, nb_combi))
set.seed(27011996, kind = "L'Ecuyer-CMRG")
AGarder <- sample.int(1000000, 10, replace = F) # vector of seeds
set.seed(AGarder[3], kind = "L'Ecuyer-CMRG")
# response data to monotherapies for each patient are simulated with an individual IC50
# drawn from a Gaussian with mean mu_IC50_monotherapy and standard deviation sigma_IC50_monotherapy
IC50_monotherapy <- matrix(rep(NA, J * nb_pat), nrow = nb_pat)
for (j in 1:J) {
v <-
rnorm(nb_pat, mu_IC50_monotherapy[j], sigma_IC50_monotherapy[j])
for (i in 1:nb_pat) {
v[i] <- ifelse(v[i] > 0, v[i], 0)
}
IC50_monotherapy[, j] <- v
}
# response data to combinationsfor each patient are simulated with an individual IC50
# drawn from a Gaussian with mean mu_IC50_combi and standard deviation sigma_IC50_combi
IC50_combi <- matrix(rep(NA, nb_combi * nb_pat), nrow = nb_pat)
for (j in 1:nb_combi) {
v <-   rnorm(nb_pat, mu_IC50_combi[j], sigma_IC50_combi[j])
for (i in 1:nb_pat) {
v[i] <- ifelse(v[i] > 0, v[i], 0)
}
IC50_combi[, j] <- v
}
# nb_well represents the vector of number of combinations we are able to test on each patient
nb_well <- c(rep(NA, nb_pat))
if (nb_pat %% 2 == 0) {
for (pat in 1:(0.5 * nb_pat)) {
nb_well[pat] <- nb_combi
}
for (pat in (0.5 * nb_pat + 1):nb_pat) {
nb_well[pat] <- sample(c(6:(nb_combi-1)), 1)
}
} else{
for (pat in 1:floor(0.5 * nb_pat)) {
nb_well[pat] <- nb_combi
}
for (pat in (floor(0.5 * nb_pat) + 1):(floor(0.5 * nb_pat) + ceiling(0.5 *
nb_pat))) {
nb_well[pat] <- sample(c(6:(nb_combi-1)), 1)
}
}
# random initial ranking
ranking_crossD <- sample(ranking0)
ranking_crossD
# data simulation
data_combi <-
Simulation_response_combination(ranking_crossD, nb_pat, nb_well, b, c, d, IC50_combi, standard_error, x1)
data_mono <-
Simulation_response_monotherapy(nb_pat, J, b_mono, c_mono, d_mono, IC50_monotherapy, standard_error, x1)
# generation of indexes for each pair of patient-tested combination
data_combi$Index_pat_combi <- paste(data_combi$patient, data_combi$Combi)
provisoire <- data_combi[!duplicated(data_combi$Index_pat_combi), ]
provisoire$Index_Stan <- c(seq(1:dim(provisoire)[1]))
data_combi$Index_Stan <- c(rep(NA, dim(data_combi)[1]))
for (i in 1:dim(provisoire)[1]) {
data_combi$Index_Stan <-
ifelse(
data_combi$Index_pat_combi == provisoire$Index_pat_combi[i],
provisoire$Index_Stan[i] ,
data_combi$Index_Stan
)
}
# all monotherapies are tested on every patients
vect_mono <- c()
for (i in 1:nb_pat) {
for (j in 1:J) {
vect_mono <- c(vect_mono, paste0("IC50_mono[", i, "," , j, "]"))
}
}
# data for the stan model
data_stan <- list(
N = dim(data_combi)[1],
nb_combi = nb_combi,
combi = data_combi$Combi,
Dose = data_combi$Dose,
y = data_combi$y,
pat = data_combi$patient,
med_combi = c(rep(median(x1), nb_combi)),
index = data_combi$Index_Stan,
respective_combi = provisoire$Combi,
nbOBS_mono = dim(data_mono)[1],
J = J,
drug = data_mono$Drug,
x_mono = data_mono$Dose,
y_mono = data_mono$y_mono,
pat_mono = data_mono$patient,
med = c(rep(median(x1), J)) ,
nb_pat = length(table(data_combi$patient))
)
# load packages and functions
library(rstan)
library(tidyverse)
library(doParallel)
library(doRNG)
library(doSNOW)
library(matrixStats)
# this code computed RAW RESULTS for 5 simulations : final rankings (marginal and individual)
source("./functions.R")
?saveRDS
setwd("Z:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
pointsize <- 0.7
titlesize <- 18
library(ggplot2)
library(sf)
library(dplyr)
# # Read the shapefile
# germany <- st_read("./Simulations/spatial/data/DEU_adm2.shp")
#
# # Filter the state of Bavaria and unify it as a whole
# bavaria <- germany %>%
#   filter(NAME_1 == "Bayern") %>%
#   st_union()
#
# # Generate a random set of points within the Bavaria polygon
# set.seed(42) # for reproducibility
# n_points <- 2000 # number of points to generate
# grid_points <- st_sample(bavaria, size = n_points, type = "random", crs = st_crs(bavaria))
#
#
#
#
#
#
# # Convert to a data frame for ggplot2
# grid_points_df <- data.frame(st_coordinates(grid_points))
#
# # Draw a vertical line about in the middle of Bavaria
# vertical_line_x <- st_bbox(bavaria)[1] + 0.6*(st_bbox(bavaria)[3] - st_bbox(bavaria)[1])#mean(st_bbox(bavaria)[c(1, 3)])
#
#
# # Define the start and end of the vertical line to be within the bounds of Bavaria
# vertical_line_y_start <- min(st_bbox(bavaria)[c(2, 4)])
# vertical_line_y_end <- max(st_bbox(bavaria)[c(2, 4)])
#
# # Color all points left to the line with one color, and all points right to the line with another color
# grid_points_df$color <- ifelse(grid_points_df$X <= vertical_line_x, scales::hue_pal()(2)[2], scales::hue_pal()(2)[1])
#
# # Find the intersection of the Bavaria polygon and the vertical line
# # Create the vertical line as a simple feature line
# vertical_line <- st_sfc(st_linestring(rbind(c(vertical_line_x, vertical_line_y_start),
#                                             c(vertical_line_x, vertical_line_y_end))),
#                         crs = st_crs(bavaria))
#
# # Find the intersection of the line with Bavaria
# intersected_line <- st_intersection(vertical_line, st_union(bavaria))
#
# # Convert the intersected_line to a dataframe for plotting
# intersected_line_df <- data.frame(st_coordinates(intersected_line))
#
# # Add the intersected line to the plot
# p1 <- ggplot() +
#   geom_point(data = grid_points_df, aes(X, Y, color = color), size=pointsize) +
#   geom_sf(data = bavaria, fill = NA, color = "black", linewidth = 1) +
#   geom_line(data = intersected_line_df, aes(X, Y), color = "black", linewidth = 1) +
#   scale_color_identity() +
#   theme_bw() +
#   theme(legend.position = "none", axis.text=element_blank(),
#         axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         axis.title=element_blank(),
#         plot.title = element_text(size = titlesize)) +
#   coord_sf() +
#   ggtitle("\nSingle split into training and test data")
#
# p1
# Convert to a data frame for ggplot2
grid_points_df <- data.frame(st_coordinates(grid_points))
setwd("Z:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
pointsize <- 0.7
titlesize <- 18
library(ggplot2)
library(sf)
library(dplyr)
# Read the shapefile
germany <- st_read("./Simulations/spatial/data/DEU_adm2.shp")
# Filter the state of Bavaria and unify it as a whole
bavaria <- germany %>%
filter(NAME_1 == "Bayern") %>%
st_union()
# Generate a random set of points within the Bavaria polygon
set.seed(42) # for reproducibility
n_points <- 2000 # number of points to generate
grid_points <- st_sample(bavaria, size = n_points, type = "random", crs = st_crs(bavaria))
# # Convert to a data frame for ggplot2
# grid_points_df <- data.frame(st_coordinates(grid_points))
#
# # Draw a vertical line about in the middle of Bavaria
# vertical_line_x <- st_bbox(bavaria)[1] + 0.6*(st_bbox(bavaria)[3] - st_bbox(bavaria)[1])#mean(st_bbox(bavaria)[c(1, 3)])
#
#
# # Define the start and end of the vertical line to be within the bounds of Bavaria
# vertical_line_y_start <- min(st_bbox(bavaria)[c(2, 4)])
# vertical_line_y_end <- max(st_bbox(bavaria)[c(2, 4)])
#
# # Color all points left to the line with one color, and all points right to the line with another color
# grid_points_df$color <- ifelse(grid_points_df$X <= vertical_line_x, scales::hue_pal()(2)[2], scales::hue_pal()(2)[1])
#
# # Find the intersection of the Bavaria polygon and the vertical line
# # Create the vertical line as a simple feature line
# vertical_line <- st_sfc(st_linestring(rbind(c(vertical_line_x, vertical_line_y_start),
#                                             c(vertical_line_x, vertical_line_y_end))),
#                         crs = st_crs(bavaria))
#
# # Find the intersection of the line with Bavaria
# intersected_line <- st_intersection(vertical_line, st_union(bavaria))
#
# # Convert the intersected_line to a dataframe for plotting
# intersected_line_df <- data.frame(st_coordinates(intersected_line))
#
# # Add the intersected line to the plot
# p1 <- ggplot() +
#   geom_point(data = grid_points_df, aes(X, Y, color = color), size=pointsize) +
#   geom_sf(data = bavaria, fill = NA, color = "black", linewidth = 1) +
#   geom_line(data = intersected_line_df, aes(X, Y), color = "black", linewidth = 1) +
#   scale_color_identity() +
#   theme_bw() +
#   theme(legend.position = "none", axis.text=element_blank(),
#         axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         axis.title=element_blank(),
#         plot.title = element_text(size = titlesize)) +
#   coord_sf() +
#   ggtitle("\nSingle split into training and test data")
#
# p1
# Convert to a data frame for ggplot2
grid_points_df <- data.frame(st_coordinates(grid_points))
# Define equidistant points for vertical and horizontal lines
num_lines <- 6 # this will create 5 squares
x_coords <- seq(st_bbox(bavaria)[1], st_bbox(bavaria)[3], length.out = num_lines)
y_coords <- seq(st_bbox(bavaria)[2], st_bbox(bavaria)[4], length.out = num_lines)
# Initialize empty list to hold lines
grid_lines <- list()
# Create vertical and horizontal lines and intersect them with Bavaria
for (i in 1:(num_lines-1)) {
vertical_line <- st_sfc(st_linestring(rbind(c(x_coords[i], min(y_coords)),
c(x_coords[i], max(y_coords)))),
crs = st_crs(bavaria))
horizontal_line <- st_sfc(st_linestring(rbind(c(min(x_coords), y_coords[i]),
c(max(x_coords), y_coords[i]))),
crs = st_crs(bavaria))
intersected_vline <- data.frame(st_coordinates(st_intersection(vertical_line, st_union(bavaria))))
intersected_hline <- data.frame(st_coordinates(st_intersection(horizontal_line, st_union(bavaria))))
# Add to list
grid_lines[[paste0("vline", i)]] <- intersected_vline
grid_lines[[paste0("hline", i)]] <- intersected_hline
}
# Determine square for each point
grid_points_df$square <- findInterval(grid_points_df$X, x_coords) +
(findInterval(grid_points_df$Y, y_coords) - 1) * (num_lines - 1)
# Color all points in the second square from the top and from the left with one color,
# and all other points with another color
grid_points_df$color <- ifelse(grid_points_df$square == 18, scales::hue_pal()(2)[1], scales::hue_pal()(2)[2])
# Add the grid lines and colored points to the plot
p2 <- ggplot() +
geom_point(data = grid_points_df, aes(X, Y, color = color), size=pointsize) +
geom_sf(data = bavaria, fill = NA, color = "black", linewidth = 1) +
geom_line(data = grid_lines[[1]], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[2]], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[3]][1:2,], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[3]][3:8,], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[4]], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[5]], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[6]], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[7]], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[8]], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[9]][1:2,], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[9]][3:4,], aes(X, Y), color = "black", linewidth = 1) +
geom_line(data = grid_lines[[10]], aes(X, Y), color = "black", linewidth = 1) +
scale_color_identity() +
theme_bw() +
theme(legend.position = "none", axis.text=element_blank(),
axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title=element_blank(),
plot.title = element_text(size = titlesize)) +
coord_sf() +
ggtitle("\nRectangular tiles")
p2
# # Convert to a data frame for ggplot2
# grid_points_df <- data.frame(st_coordinates(grid_points))
#
# # Apply k-means clustering with k=8
# set.seed(42) # for reproducibility
# clustering <- kmeans(grid_points_df, centers = 8)
# grid_points_df$cluster <- as.factor(clustering$cluster)
# grid_points_df$color <- ifelse(grid_points_df$cluster == 5, scales::hue_pal()(2)[2], scales::hue_pal()(2)[1])
#
# # Calculate convex hull for each cluster and create polygons
# hulls <- by(grid_points_df, grid_points_df$cluster, function(df) df[chull(df$X, df$Y), ])
# hulls_list <- lapply(hulls, function(df) {
#   coords <- df[c("X", "Y")]
#   # Ensure the polygon is closed
#   coords <- rbind(coords, coords[1, ])
#   st_polygon(list(as.matrix(coords)))
# })
#
# # Convert list to sf object
# hulls_sf <- st_sfc(hulls_list, crs = st_crs(bavaria))
#
# # Intersect hulls with Bavaria to remove lines outside Bavaria
# hulls_sf <- st_intersection(hulls_sf, bavaria)
#
# p3 <- ggplot() +
#   geom_point(data = grid_points_df, aes(X, Y, color = color), size=pointsize) +
#   geom_sf(data = bavaria, fill = NA, color = "black", linewidth = 1) +
#   geom_sf(data = hulls_sf, fill = NA, color = "black", linewidth=1) +
#   theme_bw() +
#   theme(legend.position = "none", axis.text=element_blank(),
#         axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         axis.title=element_blank(),
#         plot.title = element_text(size = titlesize)) +
#   coord_sf() +
#   ggtitle("k clustered groups with clustering based\non the coordinates")
# p3
library(ggforce)  # for geom_ellipse
# Convert to a data frame for ggplot2
grid_points_df <- data.frame(st_coordinates(grid_points))
colnames(grid_points_df) <- c("X", "Y")
# Center of Munich
test_point <- data.frame(X = 11.5820, Y = 48.1351)
# Define the semi-major and semi-minor axes of the ellipse
semi_major_axis <- 0.35*0.2/0.13  # adjust this value to change the width of the ellipse
semi_minor_axis <- 0.35    # adjust this value to change the height of the ellipse
# Calculate the distance of each point to the test point
dist_to_test_point <- sqrt((grid_points_df$X - test_point$X)^2 / semi_major_axis^2 +
(grid_points_df$Y - test_point$Y)^2 / semi_minor_axis^2)
# Filter points outside the buffer
points_outside_buffer <- grid_points_df[dist_to_test_point > 1, ]
# Create plot
p4 <- ggplot() +
geom_point(data = points_outside_buffer, aes(X, Y), color = scales::hue_pal()(2)[2], size=pointsize) +
geom_point(data = test_point, aes(X, Y), color = scales::hue_pal()(2)[1], size=pointsize) +
geom_sf(data = bavaria, fill = NA, color = "black", linewidth = 1) +
ggforce::geom_ellipse(aes(x0 = test_point$X, y0 = test_point$Y, a = semi_major_axis, b = semi_minor_axis, angle = 0),
fill = NA, color = "black", linetype = "solid", linewidth = 1) +
theme_bw() +
theme(legend.position = "none", axis.text=element_blank(),
axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title=element_blank(),
plot.title = element_text(size = titlesize)) +
coord_sf() +
ggtitle("Leave-one-out cross-validation with\nbuffer")
p4
# # Convert to a data frame for ggplot2
# grid_points_df <- data.frame(st_coordinates(grid_points))
# colnames(grid_points_df) <- c("X", "Y")
#
# # Center of Munich
# test_point <- data.frame(X = 11.5820, Y = 48.1351)
#
# # Define the semi-major and semi-minor axes of the outer ellipse
# semi_major_axis_outer <- 0.35*0.2/0.13
# semi_minor_axis_outer <- 0.35
#
# # Define the semi-major and semi-minor axes of the inner ellipse
# semi_major_axis_inner <- 0.2
# semi_minor_axis_inner <- 0.13
#
# # Calculate the distance of each point to the test point for outer and inner ellipses
# dist_to_test_point_outer <- sqrt((grid_points_df$X - test_point$X)^2 / semi_major_axis_outer^2 +
#                                    (grid_points_df$Y - test_point$Y)^2 / semi_minor_axis_outer^2)
#
# dist_to_test_point_inner <- sqrt((grid_points_df$X - test_point$X)^2 / semi_major_axis_inner^2 +
#                                    (grid_points_df$Y - test_point$Y)^2 / semi_minor_axis_inner^2)
#
# # Filter points outside the outer buffer and inside the inner buffer
# points_outside_buffer <- grid_points_df[dist_to_test_point_outer > 1 & dist_to_test_point_inner > 1, ]
#
# # Points inside the inner buffer
# points_inside_buffer <- grid_points_df[dist_to_test_point_inner <= 1, ]
#
# # Create plot
# p5 <- ggplot() +
#   geom_point(data = points_outside_buffer, aes(X, Y), color = scales::hue_pal()(2)[2], size=pointsize) +
#   geom_point(data = points_inside_buffer, aes(X, Y), color = scales::hue_pal()(2)[1], size=pointsize) +
#   geom_sf(data = bavaria, fill = NA, color = "black", linewidth = 1) +
#   ggforce::geom_ellipse(aes(x0 = test_point$X, y0 = test_point$Y, a = semi_major_axis_outer, b = semi_minor_axis_outer, angle = 0),
#                         fill = NA, color = "black", linetype = "solid", linewidth = 1) +
#   ggforce::geom_ellipse(aes(x0 = test_point$X, y0 = test_point$Y, a = semi_major_axis_inner, b = semi_minor_axis_inner, angle = 0),
#                         fill = NA, color = "black", linetype = "solid", linewidth = 1) +
#   theme_bw() +
#   theme(legend.position = "none", axis.text=element_blank(),
#         axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         axis.title=element_blank(),
#         plot.title = element_text(size = titlesize)) +
#   coord_sf() +
#   ggtitle("Leave-one-disc-out cross-validation with\nbuffer")
#
# p5
# Filter the districts in Bavaria
bavaria_districts <- germany %>%
filter(NAME_1 == "Bayern") # 'NAME_1' is assumed to be the column containing the state names. This might change according to the structure of your data.
# Find out which points are within Oberbayern
oberbayern <- bavaria_districts %>% filter(NAME_2 == "Oberbayern")
# Convert to a data frame for ggplot2
grid_points_df <- data.frame(st_coordinates(grid_points))
# Define which district each point belongs to
grid_points_df$in_oberbayern <- st_within(grid_points, oberbayern, sparse = FALSE)
# Create the plot
p6 <- ggplot() +
geom_point(data = grid_points_df, aes(X, Y, color = in_oberbayern), size=pointsize) +
geom_sf(data = bavaria_districts, fill = NA, color = "black", linewidth = 1) +
scale_color_manual(values = c("TRUE" = scales::hue_pal()(2)[1], "FALSE" = scales::hue_pal()(2)[2])) +
theme_bw() +
labs(color = "In Oberbayern") +
theme(legend.position = "none", axis.text=element_blank(),
axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.title=element_blank(),
plot.title = element_text(size = titlesize)) +
coord_sf() + ggtitle("\nPartitioning based on geographical units")
p6
library("gridExtra")
# p <- grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
# p
p <- grid.arrange(p2, p4, p6, ncol=3)
p
ggsave("./simulations/spatial/results/figures/spatialvis_small.pdf", plot=p, width=10*1.5, height=3.5*1.5)
