angles <- seq(0, 360, length.out = n_petals + 1)
radii <- c(rep(radius, n_petals), radius/2)
df <- data.frame(angle = angles, radius = radii)
df$x <- df$radius * cos(df$angle * pi/180) + center[1]
df$y <- df$radius * sin(df$angle * pi/180) + center[2]
ggplot() +
geom_path(data = df, aes(x = x, y = y)) +
coord_fixed() +
theme_void()
}
draw_rose(n_petals = 16, center = c(1,1), radius = 2)
nchar("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
(19 + (10/60)) - (13 + (56/60))
(19 + (10/60)) - (13 + (56/60))  + 2
setwd("D:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
source("./simulations/hierpr/functions_simulation.R")
setwd("D:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
source("./simulations/hierpr/functions_simulation.R")
setwd("D:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
source("./simulations/hierpr/functions_simulation.R")
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=500, coeflist=coeflist)
datatest <- sim_data(n=1000, coeflist=coeflist)
dim(datatrain)
# Load the required packages:
library("mlr3")
library("hierclass")
library(devtools)
install_github("RomanHornung/hierclass")
# Load the required packages:
library("mlr3")
library("hierclass")
lgr::get_logger("mlr3")$set_threshold("warn")
# Set seed for reproducibility:
# set.seed(123)
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datatrain)
# Initialize the learner for the top-down classification rule:
learner = lrn("classif.topdown")
# set.seed(1234)
cv3 <- rsmp("repeated_cv", repeats = 1, folds = 2)
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
CV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
# set.seed(1234)
task$col_roles$stratum = task$target_names
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
stratCV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
datacompl <- rbind(datatrain, datatest)
ntrain <- nrow(datatrain); nall <- nrow(datacompl)
rm(datatrain, datatest); gc()
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datacompl)
learner$train(task, row_ids = 1:ntrain)
predictions = learner$predict(task, row_ids = (ntrain+1):nall)
truth_vals <- c(predictions$score(msr("classif.hierfbeta", type="micro")),
predictions$score(msr("classif.hierfbeta", type="macro")),
predictions$score(msr("classif.hierpr", type="micro")),
predictions$score(msr("classif.hierpr", type="macro")),
predictions$score(msr("classif.hierre", type="micro")),
predictions$score(msr("classif.hierre", type="macro")),
predictions$score(msr("classif.hloss")),
predictions$score(msr("classif.spath")),
predictions$score(msr("classif.acc")))
res <- data.frame(measure=c("hierf_micro", "hierf_macro", "hierpr_micro",
"hierpr_macro", "hierre_micro", "hierre_macro",
"hloss", "spath", "acc"), CV_vals=CV_vals,
stratCV_vals=stratCV_vals, truth_vals=truth_vals)
res
table(datatrain$y)
setwd("D:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
source("./simulations/hierpr/functions_simulation.R")
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=500, coeflist=coeflist)
table(datatrain$y)
barplot(table(datatrain$y))
table(table(datatrain$y))
barplot(table(table(datatrain$y)))
mean(table(table(datatrain$y)))
median(table(table(datatrain$y)))
median(table(table(datatrain$y))[table(table(datatrain$y))==0])
median(table(table(datatrain$y))[table(table(datatrain$y))!=0])
table(table(datatrain$y))[table(table(datatrain$y))!=0]
res
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
table(datatrain$y)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
datatest <- sim_data(n=1000, coeflist=coeflist)
# Load the required packages:
library("mlr3")
library("hierclass")
lgr::get_logger("mlr3")$set_threshold("warn")
# Set seed for reproducibility:
# set.seed(123)
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datatrain)
# Initialize the learner for the top-down classification rule:
learner = lrn("classif.topdown")
# set.seed(1234)
cv3 <- rsmp("repeated_cv", repeats = 1, folds = 2)
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
CV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
# set.seed(1234)
task$col_roles$stratum = task$target_names
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
stratCV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
datacompl <- rbind(datatrain, datatest)
ntrain <- nrow(datatrain); nall <- nrow(datacompl)
rm(datatrain, datatest); gc()
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datacompl)
learner$train(task, row_ids = 1:ntrain)
predictions = learner$predict(task, row_ids = (ntrain+1):nall)
truth_vals <- c(predictions$score(msr("classif.hierfbeta", type="micro")),
predictions$score(msr("classif.hierfbeta", type="macro")),
predictions$score(msr("classif.hierpr", type="micro")),
predictions$score(msr("classif.hierpr", type="macro")),
predictions$score(msr("classif.hierre", type="micro")),
predictions$score(msr("classif.hierre", type="macro")),
predictions$score(msr("classif.hloss")),
predictions$score(msr("classif.spath")),
predictions$score(msr("classif.acc")))
res <- data.frame(measure=c("hierf_micro", "hierf_macro", "hierpr_micro",
"hierpr_macro", "hierre_micro", "hierre_macro",
"hloss", "spath", "acc"), CV_vals=CV_vals,
stratCV_vals=stratCV_vals, truth_vals=truth_vals)
res
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
datatest <- sim_data(n=1000, coeflist=coeflist)
# Load the required packages:
library("mlr3")
library("hierclass")
lgr::get_logger("mlr3")$set_threshold("warn")
# Set seed for reproducibility:
# set.seed(123)
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datatrain)
# Initialize the learner for the top-down classification rule:
learner = lrn("classif.topdown")
# set.seed(1234)
cv3 <- rsmp("repeated_cv", repeats = 1, folds = 2)
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
CV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
# set.seed(1234)
task$col_roles$stratum = task$target_names
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
stratCV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
datacompl <- rbind(datatrain, datatest)
ntrain <- nrow(datatrain); nall <- nrow(datacompl)
rm(datatrain, datatest); gc()
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datacompl)
learner$train(task, row_ids = 1:ntrain)
predictions = learner$predict(task, row_ids = (ntrain+1):nall)
truth_vals <- c(predictions$score(msr("classif.hierfbeta", type="micro")),
predictions$score(msr("classif.hierfbeta", type="macro")),
predictions$score(msr("classif.hierpr", type="micro")),
predictions$score(msr("classif.hierpr", type="macro")),
predictions$score(msr("classif.hierre", type="micro")),
predictions$score(msr("classif.hierre", type="macro")),
predictions$score(msr("classif.hloss")),
predictions$score(msr("classif.spath")),
predictions$score(msr("classif.acc")))
res <- data.frame(measure=c("hierf_micro", "hierf_macro", "hierpr_micro",
"hierpr_macro", "hierre_micro", "hierre_macro",
"hloss", "spath", "acc"), CV_vals=CV_vals,
stratCV_vals=stratCV_vals, truth_vals=truth_vals)
res
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
datatest <- sim_data(n=1000, coeflist=coeflist)
# Load the required packages:
library("mlr3")
library("hierclass")
lgr::get_logger("mlr3")$set_threshold("warn")
# Set seed for reproducibility:
# set.seed(123)
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datatrain)
# Initialize the learner for the top-down classification rule:
learner = lrn("classif.topdown")
# set.seed(1234)
cv3 <- rsmp("repeated_cv", repeats = 1, folds = 2)
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
CV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
# set.seed(1234)
task$col_roles$stratum = task$target_names
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
stratCV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
datacompl <- rbind(datatrain, datatest)
ntrain <- nrow(datatrain); nall <- nrow(datacompl)
rm(datatrain, datatest); gc()
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datacompl)
learner$train(task, row_ids = 1:ntrain)
predictions = learner$predict(task, row_ids = (ntrain+1):nall)
truth_vals <- c(predictions$score(msr("classif.hierfbeta", type="micro")),
predictions$score(msr("classif.hierfbeta", type="macro")),
predictions$score(msr("classif.hierpr", type="micro")),
predictions$score(msr("classif.hierpr", type="macro")),
predictions$score(msr("classif.hierre", type="micro")),
predictions$score(msr("classif.hierre", type="macro")),
predictions$score(msr("classif.hloss")),
predictions$score(msr("classif.spath")),
predictions$score(msr("classif.acc")))
res <- data.frame(measure=c("hierf_micro", "hierf_macro", "hierpr_micro",
"hierpr_macro", "hierre_micro", "hierre_macro",
"hloss", "spath", "acc"), CV_vals=CV_vals,
stratCV_vals=stratCV_vals, truth_vals=truth_vals)
res
200*4/5
setwd("D:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
source("./simulations/hierpr/functions_simulation.R")
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=100, coeflist=coeflist)
datatest <- sim_data(n=1000, coeflist=coeflist)
# Load the required packages:
library("mlr3")
library("hierclass")
lgr::get_logger("mlr3")$set_threshold("warn")
# Set seed for reproducibility:
# set.seed(123)
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datatrain)
# Initialize the learner for the top-down classification rule:
learner = lrn("classif.topdown")
# set.seed(1234)
cv3 <- rsmp("repeated_cv", repeats = 1, folds = 5)
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
CV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
# set.seed(1234)
task$col_roles$stratum = task$target_names
cv3$instantiate(task)
result_cv3 <- resample(task=task, learner=learner, resampling=cv3)
stratCV_vals <- c(result_cv3$aggregate(msr("classif.hierfbeta", type="micro")),
result_cv3$aggregate(msr("classif.hierfbeta", type="macro")),
result_cv3$aggregate(msr("classif.hierpr", type="micro")),
result_cv3$aggregate(msr("classif.hierpr", type="macro")),
result_cv3$aggregate(msr("classif.hierre", type="micro")),
result_cv3$aggregate(msr("classif.hierre", type="macro")),
result_cv3$aggregate(msr("classif.hloss")),
result_cv3$aggregate(msr("classif.spath")),
result_cv3$aggregate(msr("classif.acc")))
datacompl <- rbind(datatrain, datatest)
ntrain <- nrow(datatrain); nall <- nrow(datacompl)
rm(datatrain, datatest); gc()
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datacompl)
learner$train(task, row_ids = 1:ntrain)
predictions = learner$predict(task, row_ids = (ntrain+1):nall)
truth_vals <- c(predictions$score(msr("classif.hierfbeta", type="micro")),
predictions$score(msr("classif.hierfbeta", type="macro")),
predictions$score(msr("classif.hierpr", type="micro")),
predictions$score(msr("classif.hierpr", type="macro")),
predictions$score(msr("classif.hierre", type="micro")),
predictions$score(msr("classif.hierre", type="macro")),
predictions$score(msr("classif.hloss")),
predictions$score(msr("classif.spath")),
predictions$score(msr("classif.acc")))
res <- data.frame(measure=c("hierf_micro", "hierf_macro", "hierpr_micro",
"hierpr_macro", "hierre_micro", "hierre_macro",
"hloss", "spath", "acc"), CV_vals=CV_vals,
stratCV_vals=stratCV_vals, truth_vals=truth_vals)
res
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=100, coeflist=coeflist)
table(datatrain$y)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
table(datatrain$y)
barplot(table(datatrain$y))
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
barplot(table(datatrain$y))
datatrain <- sim_data(n=1000, coeflist=coeflist)
barplot(table(datatrain$y))
datatrain <- sim_data(n=1000, coeflist=coeflist)
barplot(table(datatrain$y))
datatrain <- sim_data(n=1000, coeflist=coeflist)
barplot(table(datatrain$y))
datatrain <- sim_data(n=1000, coeflist=coeflist)
barplot(table(datatrain$y))
datatrain <- sim_data(n=1000, coeflist=coeflist)
barplot(table(datatrain$y))
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=1000, coeflist=coeflist)
barplot(table(datatrain$y))
# Make table of settings:
n <- c(200, 500, 1000, 3000)
iters <- 1:100
scenariogrid <- expand.grid(iter=iters, n=n, stringsAsFactors = TRUE)
scenariogrid <- scenariogrid[,ncol(scenariogrid):1, drop=FALSE]
set.seed(1234)
seeds <- sample(1000:10000000, size=nrow(scenariogrid)*2)
scenariogrid$seed_start <- seeds[1:nrow(scenariogrid)]
scenariogrid$seed_res <- seeds[(nrow(scenariogrid)+1):length(seeds)]
set.seed(1234)
reorderind <- sample(1:nrow(scenariogrid))
scenariogrid <- scenariogrid[reorderind,,drop=FALSE]
rownames(scenariogrid) <- NULL
dim(scenariogrid)
fix(scenariogrid)
