foldstratCV
foldCV
set.seed(1234)
object <- topdown(y ~ ., data=datatrain)
dim(datatest)
rm(list=ls());gc()
setwd("Z:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
# Load and pre-process the results:
###################################
load("./hierpr/results/intermediate_results/scenariogrid.Rda")
load("./hierpr/results/intermediate_results/results.Rda")
ls()
class(results)
length(results)
results[[1]]
source("./hierpr/functions_simulation.R")
load("./hierpr/results/intermediate_results/treestruc.Rda")
set.seed(1234)
coeflist <- simulate_coefs(treestruc=treestruc, sdbeta0=sqrt(1),
sdbeta=sqrt(c(2.5, 2, 0.9, 0.7, 0.5)))
datatrain <- sim_data(n=200, coeflist=coeflist)
datatest <- sim_data(n=20000, coeflist=coeflist)
library("hierclass")
library("mlr3")
# Define the task for the top-down classification rule:
task = as_task_classif(y ~ ., data = datatrain)
# Initialize the learner for the top-down classification rule:
learner = lrn("classif.topdown")
cv3 <- rsmp("repeated_cv", repeats = 1, folds = 5)
cv3$instantiate(task)
foldinfoCV <- as.data.frame(cv3$instance)
foldinfoCV <- foldinfoCV[order(foldinfoCV$row_id),]
ynew <- datatrain$y
ynew <- factor(as.character(ynew))
foldCV <- sapply(1:5, function(x) table(ynew[foldinfoCV$fold==x]))#/sum(table(ynew[ui$fold==x])))
# Statement: [regarding CV and ntrain = 200] "... small classes frequently did not occur in the test folds in CV..."
foldCV
task$col_roles$stratum = task$target_names
cv3$instantiate(task)
foldinfostratCV <- as.data.frame(cv3$instance)
foldinfostratCV <- foldinfostratCV[order(foldinfostratCV$row_id),]
foldstratCV <- sapply(1:5, function(x) table(ynew[foldinfostratCV$fold==x]))
# Statement: "This is because, for $\ntrain = 200$, small classes often only featured very few observations ($< 5$), ..."
# Statement: "..., for $\ntrain = 200$, many small classes did not even occur in the training sets ..."
table(datatrain$y)
# Statement: [regarding stratified CV] "..., which had the effect that only a subset of the folds featured these classes."
foldstratCV
set.seed(1234)
datatesthuge <- sim_data(n=200000, coeflist=coeflist)
object <- topdown(y ~ ., data=datatrain)
preds <- mypredict(object, data=datatesthuge)
preds <- predict(object, data=datatesthuge)
class(preds)
length(preds)
table(preds)
table(datatrain$y)
ui <- cbind(table(datatrain$y), table(preds))
ui
names(table(preds))
tempdf <- data.frame(class=names(table(datatrain$y)), ntrain=table(datatrain$y), npred=table(preds))
fix(tempdf)
table(datatrain$y)
as.vector(table(datatrain$y))
tempdf <- data.frame(class=names(table(datatrain$y)), ntrain=as.vector(table(datatrain$y)), npred=as.vector(table(preds)))
fix(tempdf)
tempdf
hierre
myhierre <- function(truth, response, type="micro") {
if (!(type %in% c("micro", "macro")))
stop("'type' has to be either 'micro' or 'macro'.")
# Convert the factors to characters, because we perform string
# operations on them:
truth <- as.character(truth)
response <- as.character(response)
# Replace the NA predictions to predictions of the root class:
response[is.na(response)] <- "rootclass"
truthall <- sapply(truth, strsplit, split="\\.")
responseall <- sapply(response, strsplit, split="\\.")
if (type=="micro") {
# Micro average:
nominator <- sum(mapply(function(x, y) length(intersect(x, y)), truthall, responseall))
denominator <- length(unlist(truthall))
result <- nominator/denominator
} else {
# Macro average:
truthleaf <- sapply(truthall, function(x) x[length(x)])
truthleafun <- unique(truthleaf)
rel <- sapply(truthleafun, function(l) {
nominator <- sum(mapply(function(x, y) length(intersect(x, y)), truthall[truthleaf==l], responseall[truthleaf==l]))
denominator <- length(unlist(truthall[truthleaf==l]))
nominator/denominator
})
result <- data.frame(class=truthleafun, Rel=rel)
# result <- mean(rel)
}
return(result)
}
myhierpr <- function(truth, response, type="micro") {
if (!(type %in% c("micro", "macro")))
stop("'type' has to be either 'micro' or 'macro'.")
# Convert the factors to characters, because we perform string
# operations on them:
truth <- as.character(truth)
response <- as.character(response)
# Replace the NA predictions to predictions of the root class:
response[is.na(response)] <- "rootclass"
truthall <- sapply(truth, strsplit, split="\\.")
responseall <- sapply(response, strsplit, split="\\.")
if (type=="micro") {
# Micro average:
nominator <- sum(mapply(function(x, y) length(intersect(x, y)), truthall, responseall))
denominator <- length(unlist(responseall))
result <- nominator/denominator
} else {
# Macro average:
responseleaf <- sapply(responseall, function(x) x[length(x)])
responseleafun <- unique(responseleaf)
prl <- sapply(responseleafun, function(l) {
nominator <- sum(mapply(function(x, y) length(intersect(x, y)), truthall[responseleaf==l], responseall[responseleaf==l]))
denominator <- length(unlist(responseall[responseleaf==l]))
nominator/denominator
})
result <- data.frame(class=truthleafun, Prl=prl)
# result <- mean(prl)
}
return(result)
}
rel_res <- myhierre(truth=datatesthuge$y, response=preds, type="macro")
prl_res <- myhierpr(truth=datatesthuge$y, response=preds, type="macro")
myhierpr <- function(truth, response, type="micro") {
if (!(type %in% c("micro", "macro")))
stop("'type' has to be either 'micro' or 'macro'.")
# Convert the factors to characters, because we perform string
# operations on them:
truth <- as.character(truth)
response <- as.character(response)
# Replace the NA predictions to predictions of the root class:
response[is.na(response)] <- "rootclass"
truthall <- sapply(truth, strsplit, split="\\.")
responseall <- sapply(response, strsplit, split="\\.")
if (type=="micro") {
# Micro average:
nominator <- sum(mapply(function(x, y) length(intersect(x, y)), truthall, responseall))
denominator <- length(unlist(responseall))
result <- nominator/denominator
} else {
# Macro average:
responseleaf <- sapply(responseall, function(x) x[length(x)])
responseleafun <- unique(responseleaf)
prl <- sapply(responseleafun, function(l) {
nominator <- sum(mapply(function(x, y) length(intersect(x, y)), truthall[responseleaf==l], responseall[responseleaf==l]))
denominator <- length(unlist(responseall[responseleaf==l]))
nominator/denominator
})
result <- data.frame(class=responseleafun, Prl=prl)
# result <- mean(prl)
}
return(result)
}
prl_res <- myhierpr(truth=datatesthuge$y, response=preds, type="macro")
rel_res
prl_res
prl_res$class
table(datatrain$y)
sapply(sapply(names(table(datatrain$y)), strsplit, split="\\."), function(x) x[length(x)])
tempdf <- data.frame(class=sapply(sapply(names(table(datatrain$y)), strsplit, split="\\."), function(x) x[length(x)]), ntrain=table(datatrain$y))
head(tempdf)
tempdf <- data.frame(class=sapply(sapply(names(table(datatrain$y)), strsplit, split="\\."), function(x) x[length(x)]), ntrain=as.vector(table(datatrain$y)))
head(tempdf)
?merge
head(rel_res)
rel_res2 <- merge(rel_res, tempdf)
head(rel_res2)
dim(rel_res2)
dim(rel_res)
fix(tempdf)
prl_res2 <- merge(prl_res, tempdf)
plot(rel_res2$ntrain, rel_res2$Rel)
plot(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel)
plot(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel)
cor(rel_res2$ntrain, rel_res2$Rel)
plot(prl_res2$ntrain, prl_res2$Prl)
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel, main=paste0("Cor: ", round(cor(rel_res2$ntrain, rel_res2$Rel), 2)))
plot(prl_res2$ntrain, prl_res2$Prl, main=paste0("Cor: ", round(cor(prl_res2$ntrain, prl_res2$Prl), 2)))
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel,
main=paste0("Cor: ", round(cor(rel_res2$ntrain, rel_res2$Rel), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
plot(prl_res2$ntrain, prl_res2$Prl,
main=paste0("Cor: ", round(cor(prl_res2$ntrain, prl_res2$Prl), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
pdf("./hierpr/Results/figures/class_specific_recall_precision.pdf")
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel,
main=paste0("Cor: ", round(cor(rel_res2$ntrain, rel_res2$Rel), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
plot(prl_res2$ntrain, prl_res2$Prl,
main=paste0("Cor: ", round(cor(prl_res2$ntrain, prl_res2$Prl), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
dev.off()
pdf("./hierpr/Results/figures/class_specific_recall_precision.pdf", width = 10)
pdf("./hierpr/Results/figures/class_specific_recall_precision.pdf", width = 10)
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel,
main=paste0("Cor: ", round(cor(rel_res2$ntrain, rel_res2$Rel), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
plot(prl_res2$ntrain, prl_res2$Prl,
main=paste0("Cor: ", round(cor(prl_res2$ntrain, prl_res2$Prl), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
dev.off()
pdf("./hierpr/Results/figures/class_specific_recall_precision.pdf", width = 10, height=5)
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel,
main=paste0("Cor: ", round(cor(rel_res2$ntrain, rel_res2$Rel), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
plot(prl_res2$ntrain, prl_res2$Prl,
main=paste0("Cor: ", round(cor(prl_res2$ntrain, prl_res2$Prl), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
dev.off()
pdf("./hierpr/Results/figures/class_specific_recall_precision.pdf", width = 10, height = 6)
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel,
main=paste0("Cor: ", round(cor(rel_res2$ntrain, rel_res2$Rel), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
plot(prl_res2$ntrain, prl_res2$Prl,
main=paste0("Cor: ", round(cor(prl_res2$ntrain, prl_res2$Prl), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
dev.off()
library("ranger")
objectrf <- ranger(dependent.variable.name = "y", data=datatrain)
predsrf <- predict(objectrf, data=datatesthuge)
set.seed(1234)
library("ranger")
objectrf <- ranger(dependent.variable.name = "y", data=datatrain)
predsrf <- predict(objectrf, data=datatesthuge)
head(predsrf)
names(predsrf)
set.seed(1234)
library("ranger")
objectrf <- ranger(dependent.variable.name = "y", data=datatrain)
predsrf <- predict(objectrf, data=datatesthuge)$predictions
head(predsrf)
table(predsrf)
table(datatesthuge$y)
tempdf
tempdf2 <- data.frame(class=names(table(datatrain$y)), ntrain=as.vector(table(datatrain$y)))
head(tempdf2)
table(predsrf)
data.frame(class=names(table(predsrf)), ntrain=as.vector(table(predsrf)))
tempdf1 <- data.frame(class=names(table(datatrain$y)), ntrain=as.vector(table(datatrain$y)))
tempdf2 <- data.frame(class=names(table(predsrf)), ntrain=as.vector(table(predsrf)))
tempdf2 <- data.frame(class=names(table(predsrf)), npred=as.vector(table(predsrf)))
merge(tempdf1, tempdf2)
tempdf12 <- merge(tempdf1, tempdf2)
tempdf12 <- tempdf12[!(tempdf12$ntrain==0 & tempdf12$npred==0),]
tempdf12
tempdf12 <- merge(tempdf1, tempdf2)
tempdf12 <- tempdf12[!(tempdf12$ntrain==0 & tempdf12$npred==0),]
tempdf12$predperobs <- tempdf12$npred/tempdf12$ntrain
tempdf12
plot(tempdf12$ntrain, tempdf12$predperobs)
cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman")
tempdf12 <- merge(tempdf1, tempdf2)
tempdf12 <- tempdf12[tempdf12$ntrain!=0,]
tempdf12$predperobs <- tempdf12$npred/tempdf12$ntrain
plot(tempdf12$ntrain, tempdf12$predperobs)
cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman")
plot(tempdf12$ntrain, tempdf12$predperobs, main=round(paste0("Cor: ", cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman")), 2))
plot(tempdf12$ntrain, tempdf12$predperobs, main=paste0("Cor: ", round(cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman"), 2)))
pdf("./hierpr/Results/figures/class_specific_recall_precision.pdf", width = 10, height = 6)
par(mfrow=c(1,2))
plot(rel_res2$ntrain, rel_res2$Rel,
main=paste0("Cor: ", round(cor(rel_res2$ntrain, rel_res2$Rel, method="spearman"), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
plot(prl_res2$ntrain, prl_res2$Prl,
main=paste0("Cor: ", round(cor(prl_res2$ntrain, prl_res2$Prl, method="spearman"), 2)), ylim=range(c(rel_res2$Rel, prl_res2$Prl)))
cor(prl_res2$ntrain, prl_res2$Prl)
par(mfrow=c(1,1))
dev.off()
plot(tempdf12$ntrain, tempdf12$predperobs, main=paste0("Cor: ", round(cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman"), 2)))
pdf("./hierpr/Results/figures/rf_predict_large_classes", width = 10)
plot(tempdf12$ntrain, tempdf12$predperobs, main=paste0("Cor: ", round(cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman"), 2)))
dev.off()
pdf("./hierpr/Results/figures/rf_predict_large_classes.pdf", width = 10)
plot(tempdf12$ntrain, tempdf12$predperobs, main=paste0("Cor: ", round(cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman"), 2)))
dev.off()
pdf("./hierpr/Results/figures/rf_predict_large_classes.pdf")
plot(tempdf12$ntrain, tempdf12$predperobs, main=paste0("Cor: ", round(cor(tempdf12$ntrain, tempdf12$predperobs, method="spearman"), 2)))
dev.off()
rel_res
tempdf <- data.frame(class=sapply(sapply(names(table(datatrain$y)), strsplit, split="\\."), function(x) x[length(x)]), ntrain=as.vector(table(datatrain$y)))
dim(tempdf)
head(datatrain$y)
length(tempdf$class)
length(unique(tempdf$class))
unique(tempdf$class)
table(datatrain$y)
# Statement: "This is because, for $\ntrain = 200$, small classes often only featured very few observations ($< 5$), ..."
# Statement: "..., for $\ntrain = 200$, many small classes did not even occur in the training sets ..."
table(datatrain$y)
# Statement: "This is because, for $\ntrain = 200$, small classes often only featured very few observations ($< 5$), ..."
# Statement: "..., for $\ntrain = 200$, many small classes did not even occur in the training sets ..."
table(datatrain$y)
sapply(datatrain$y, strsplit, split="\\.")
sapply(datatrain$y, function(x) strsplit(x, split="\\."))
sapply(names(table(datatrain$y)), strsplit, split="\\.")
sapply(names(table(datatrain$y)), function(x) length(strsplit(x, split="\\.")))
sapply(names(table(datatrain$y)), function(x) length(strsplit(x, split="\\.")[[1]]))
max(sapply(names(table(datatrain$y)), function(x) length(strsplit(x, split="\\.")[[1]])))
# Statement: "This is because, for $\ntrain = 200$, small classes often only featured very few observations ($< 5$), ..."
# Statement: "..., for $\ntrain = 200$, many small classes did not even occur in the training sets ..."
table(datatrain$y)[sapply(names(table(datatrain$y)), function(x) length(strsplit(x, split="\\.")[[1]]))==5]
datatrain2 <- sim_data(n=200, coeflist=coeflist)
# Statement: "This is because, for $\ntrain = 200$, small classes often only featured very few observations ($< 5$), ..."
# Statement: "..., for $\ntrain = 200$, many small classes did not even occur in the training sets ..."
table(datatrain2$y)[sapply(names(table(datatrain2$y)), function(x) length(strsplit(x, split="\\.")[[1]]))==5]
datatrain2 <- sim_data(n=200, coeflist=coeflist)
# Statement: "This is because, for $\ntrain = 200$, small classes often only featured very few observations ($< 5$), ..."
# Statement: "..., for $\ntrain = 200$, many small classes did not even occur in the training sets ..."
table(datatrain2$y)[sapply(names(table(datatrain2$y)), function(x) length(strsplit(x, split="\\.")[[1]]))==5]
datatrain2 <- sim_data(n=200, coeflist=coeflist)
# Statement: [regarding stratified CV] "..., which had the effect that only a subset of the folds featured these classes."
foldstratCV
length(table(datatrain2$y)[sapply(names(table(datatrain2$y)), function(x) length(strsplit(x, split="\\.")[[1]]))==5])
unique(datatesthuge$y)
length(unique(datatesthuge$y))
as.character(unique(datatesthuge$y))
leafnodeclasses <- as.character(unique(datatesthuge$y))
as.character(unique(datatrain$y))
trainclasses <- as.character(unique(datatrain$y))
freqclasses <- table(as.character(datatesthuge$y))
head(freqclasses)
freqclasses <- table(as.character(datatesthuge$y))/nrow(datatesthuge$y)
sum(freqclasses)
freqclasses <- table(as.character(datatesthuge$y))/nrow(datatesthuge)
sum(freqclasses)
freqclasses
head(leafnodeclasses)
leafnodeclasses==names(freqclasses)
trainclasses <- as.character(unique(datatrain$y))
freqclasses <- table(as.character(datatesthuge$y))/nrow(datatesthuge)
leafnodeclasses <- names(freqclasses)
leafnodeclasses==names(freqclasses)
boxplot(freqclasses ~ as.numeric(freqclasses==leafnodeclasses))
boxplot(freqclasses ~ as.numeric(freqclasses %in% leafnodeclasses))
as.numeric(freqclasses %in% leafnodeclasses)
leafnodeclasses
as.numeric(trainclasses %in% leafnodeclasses)
boxplot(freqclasses ~ as.numeric(leafnodeclasses %in% trainclasses))
boxplot(freqclasses ~ as.numeric(leafnodeclasses %in% trainclasses))
sum(!(leafnodeclasses %in% trainclasses))
tempdf <- data.frame(class=names(table(datatrain$y)), ntrain=as.vector(table(datatrain$y)), npred=as.vector(table(preds)))
fix(tempdf)
foldstratCV
foldinfoCV$fold
table(datatrain$y)
table(as.character(datatrain$y))
trainclasses
table(as.character(datatrain$y)[foldinfoCV$fold==3])
trainclasses %in% table(as.character(datatrain$y)[foldinfoCV$fold==3])
names(table(as.character(datatrain$y)[foldinfoCV$fold==3]))
trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3]))
sum(!(trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3]))))
sum(!(leafnodeclasses %in% trainclasses))
!(trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3])))
head(rel_res)
dim(rel_res)
trainclasses[!(trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3])))]
sapply(trainclasses[!(trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3])))], strsplit, split="\\.")
sapply(sapply(trainclasses[!(trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3])))], strsplit, split="\\."), function(x) x[length(x)])
classnotincluded <- sapply(sapply(trainclasses[!(trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3])))], strsplit, split="\\."), function(x) x[length(x)])
rel_res$intrain <- FALSE
rel_res$intrain[!(rel_res$class %in% classnotincluded)] <- TRUE
fix(rel_res)
foldinfoCV$fold
# Statement: "... many small classes did not even occur in the training sets ... "
sum(!(trainclasses %in% names(table(as.character(datatrain$y)[foldinfoCV$fold!=3]))))
object <- topdown(y ~ ., data=datatrain[foldinfoCV$fold!=3])
object <- topdown(y ~ ., data=datatrain[foldinfoCV$fold!=3,])
objecttemp <- topdown(y ~ ., data=datatrain[foldinfoCV$fold!=3,])
predstemp <- predict(objecttemp, data=datatrain[foldinfoCV$fold==3,])
predstemp
# Statement: "... many small classes did not even occur in the training sets ... "
sum(!(names(table(as.character(datatrain$y)[foldinfoCV$fold==3])) %in% names(table(as.character(datatrain$y)[foldinfoCV$fold!=3]))))
rel_res <- myhierre(truth=datatrain[foldinfoCV$fold==3,]$y, response=predstemp, type="macro")
rel_res#
rel_restemp <- myhierre(truth=datatrain[foldinfoCV$fold==3,]$y, response=predstemp, type="macro")
classnotincluded <- sapply(sapply(names(table(as.character(datatrain$y)[foldinfoCV$fold==3]))[!(names(table(as.character(datatrain$y)[foldinfoCV$fold==3])) %in% names(table(as.character(datatrain$y)[foldinfoCV$fold==3])))], strsplit, split="\\."), function(x) x[length(x)])
classnotincluded
names(table(as.character(datatrain$y)[foldinfoCV$fold==3]))
classnotincluded <- sapply(sapply(names(table(as.character(datatrain$y)[foldinfoCV$fold==3]))[!(names(table(as.character(datatrain$y)[foldinfoCV$fold==3])) %in% names(table(as.character(datatrain$y)[foldinfoCV$fold!=3])))], strsplit, split="\\."), function(x) x[length(x)])
classnotincluded
rel_restemp$intrain <- FALSE
rel_restemp$intrain[!(rel_restemp$class %in% classnotincluded)] <- TRUE
rel_restemp
boxplot(rel_restemp$Rel ~ rel_restemp$intrain)
wilcox.test(rel_restemp$Rel ~ rel_restemp$intrain)
foldinfoCV$fold
foldinfoCV$fold
table(datatrain$y)
trclassvec <- as.character(datatrain$y)
trclassvec
table(trclassvec)
factor(as.character(datatrain$y), levels=unique(as.character(datatrain$y)))
droplevels(datatrain$y)
trclassvec <- droplevels(datatrain$y)
table(trclassvec)
table(trclassvec[foldinfoCV$fold!=1])
table(trclassvec[foldinfoCV$fold==1])
table(trclassvec[foldinfoCV$fold!=1]/sum(trclassvec[foldinfoCV$fold!=1]))
table(trclassvec[foldinfoCV$fold!=1])/sum(foldinfoCV$fold!=1)
sum(table(trclassvec[foldinfoCV$fold!=1])/sum(foldinfoCV$fold!=1))
table(trclassvec[foldinfoCV$fold!=1])/sum(foldinfoCV$fold!=1)
table(trclassvec[foldinfoCV$fold==1])/sum(foldinfoCV$fold==1)
rbind(table(trclassvec[foldinfoCV$fold!=1])/sum(foldinfoCV$fold!=1),
table(trclassvec[foldinfoCV$fold==1])/sum(foldinfoCV$fold==1))
rbind(table(trclassvec[foldinfoCV$fold!=2])/sum(foldinfoCV$fold!=2),
table(trclassvec[foldinfoCV$fold==2])/sum(foldinfoCV$fold==2))
setwd("Z:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
# Load and pre-process the results:
###################################
load("./hierpr/results/intermediate_results/scenariogrid.Rda")
load("./hierpr/results/intermediate_results/results.Rda")
reorderind <- order(scenariogrid$n, scenariogrid$iter)
scengrid <- scenariogrid[reorderind,]
results <- results[reorderind]
scengrid$seed_start <- scengrid$seed_res <- NULL
scengrid <- scengrid[rep(1:nrow(scengrid), times=sapply(results, nrow)),]
resultstab <- do.call("rbind", results)
results <- scengrid
results <- cbind(scengrid, resultstab)
namesbefore <- c("n", "iter", "measure", "CV_vals", "stratCV_vals", "truth_vals")
if(ncol(results) == length(namesbefore) & all(names(results)==namesbefore))
names(results) <- c("n", "iter", "measure", "CV", "stratCV", "truth")
results$n <- factor(results$n)
results$measure <- factor(results$measure, levels=c("acc", "hierpr_micro", "hierpr_macro",
"hierre_micro", "hierre_macro",
"hierf_micro", "hierf_macro",
"spath", "hloss"))
results$CV_diff <- results$CV - results$truth
results$stratCV_diff <- results$stratCV - results$truth
results$CV_absdiff <- abs(results$CV - results$truth)
results$stratCV_absdiff <- abs(results$stratCV - results$truth)
results$CV_percdiff <- 100*results$CV_diff/results$truth
results$stratCV_percdiff <- 100*results$stratCV_diff/results$truth
results$CV_percabsdiff <- 100*results$CV_absdiff/results$truth
results$stratCV_percabsdiff <- 100*results$stratCV_absdiff/results$truth
results <- reshape(results, varying=c("CV", "stratCV", "truth", "CV_diff", "stratCV_diff", "CV_absdiff", "stratCV_absdiff", "CV_percdiff",
"stratCV_percdiff", "CV_percabsdiff", "stratCV_percabsdiff"),
v.names="value",
timevar="type", times=c("CV", "stratCV", "truth", "CV_diff", "stratCV_diff", "CV_absdiff", "stratCV_absdiff", "CV_percdiff",
"stratCV_percdiff", "CV_percabsdiff", "stratCV_percabsdiff"),
direction="long")
resultstemp <- results[results$type %in% c("CV", "stratCV", "truth"),]
resultstemp$type <-factor(resultstemp$type, levels=c("CV", "stratCV", "truth"))
labelstemp <- rep("", length(levels(resultstemp$n))*3)
labelstemp[seq(from=2, by=3, length=length(levels(resultstemp$n)))] <- levels(resultstemp$n)
library("ggplot2")
p <- ggplot(resultstemp, aes(x = interaction(type, n), y = value)) + theme_bw() +
geom_line(aes(group = interaction(iter, n)),
alpha = 0.5, colour = "darkgray") +
geom_boxplot(aes(fill = type), alpha = 0.5) +
facet_wrap(~measure, scales="free_y") +
scale_x_discrete(labels = labelstemp) +
xlab("n") + ylab("Evaluation metric values") +
theme(axis.ticks.x=element_blank(),
axis.text=element_text(color="black"),
legend.position = "none")
p
library("RColorBrewer")
display.brewer.all(n=3, type="div")
colors <- brewer.pal(3, "RdBu")
selectedColors <- c(colors[1], colors[3])
resultstemp <- results[results$type %in% c("CV_percdiff", "stratCV_percdiff"),]
resultstemp$type <-factor(resultstemp$type, levels=c("CV_percdiff", "stratCV_percdiff"))
library("ggplot2")
p <- ggplot(data=resultstemp, aes(x=n, y=value, fill=type)) + theme_bw() +
geom_boxplot() + geom_hline(yintercept=0, linetype="dashed", color="darkgray") +
scale_fill_manual(values=selectedColors) +
facet_wrap(~measure, scales="free_y") + ylab("Difference between estimated and true evaluation metric values divided by true values") +
theme(axis.title = element_text(color="black"), legend.position = "none")
p
resultstemp <- results[results$type %in% c("CV_percdiff", "stratCV_percdiff"),]
resultstemp$type <-factor(resultstemp$type, levels=c("CV_percdiff", "stratCV_percdiff"))
if(all(levels(resultstemp$measure) == c("acc", "hierpr_micro", "hierpr_macro", "hierre_micro", "hierre_macro", "hierf_micro", "hierf_macro", "spath", "hloss" )))
levels(resultstemp$measure) <- c("'accuracy'", "'micro-averaged hierarchical precision'", "'macro-averaged hierarchical precision'",
"'micro-averaged hierarchical recall'", "'macro-averaged hierarchical recall'",
"paste('micro-averaged hierarchical ', F[1], ' score')", "paste('macro-averaged hierarchical ', F[1], ' score')",
"'weighted shortest path loss measure'", "'H-loss'" )
library("ggplot2")
p <- ggplot(data=resultstemp, aes(x=n, y=value, fill=type)) + theme_bw() +
geom_boxplot() + geom_hline(yintercept=0, linetype="dashed", color="darkgray") +
facet_wrap(~measure, labeller = label_parsed, scales="free_y") + ylab("Difference between estimated and true evaluation metric values divided by true values") +
scale_fill_manual(values=selectedColors) +
xlab(expression(paste("n"[train]))) +
theme(axis.title = element_text(color="black", size=12),
strip.text.x = element_text(size=11),
legend.position = "none")
p
boxplot(freqclasses ~ as.numeric(leafnodeclasses %in% trainclasses))
tempdf <- data.frame(class=names(table(datatrain$y)), ntrain=as.vector(table(datatrain$y)), npred=as.vector(table(preds)))
# Statement: "... many of the smallest classes were not predicted at all, even on the huge test sets ($\ntest = 200,000$) ..."
tempdf
