ui <- gen_tree_structure(20)
ui$nodelist
set.seed(1234)
ui <- gen_tree_structure(20)
ui
set.seed(123)
ui <- gen_tree_structure(20)
ui
ui$nodelist
ui$leftnodes
ui$nodelist[[1]]
ui$nodelist[[1]][1]
1
ui$nodelist[[1]][1]
ui$nodelist[[ui$nodelist[[1]][1]]][1]
leftnodes <- 1
leftnodes <- 1
leftnodetemp <- leftnodes[1]
i <- 1
leftnodes <- 1
i <- 1
leftnodes[i+1] <- ui$nodelist[[leftnodes[i]]][1]
leftnodes
i<-2
leftnodes[i+1] <- ui$nodelist[[leftnodes[i]]][1]
leftnodes
i<-3
leftnodes[i+1] <- ui$nodelist[[leftnodes[i]]][1]
leftnodes
leftnodes[i+1] <- ui$nodelist[[leftnodes[i]]][1]
leftnodes
i<-4
leftnodes[i+1] <- ui$nodelist[[leftnodes[i]]][1]
leftnodes[i]
leftnodes <- 1
count <- 1
while(count <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
count
leftnodes <- 1
count <- 1
while(leftnodes[count] <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
leftnodes
leftnodes[count]
set.seed(123)
ui <- gen_tree_structure(40)
ui$nodelist
leftnodes <- 1
count <- 1
while(leftnodes[count] <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
leftnodes
ui$leftnodes
ui <- gen_tree_structure(100)
ui$nodelist
leftnodes <- 1
count <- 1
while(leftnodes[count] <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
leftnodes
ui$leftnodes
ui <- gen_tree_structure(500)
leftnodes <- 1
count <- 1
while(leftnodes[count] <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
leftnodes
ui$leftnodes
ui$rightnodes
rigthnodes <- 1
leftnodes
set.seed(123)
ui <- gen_tree_structure(20)
leftnodes <- 1
count <- 1
while(leftnodes[count] <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
leftnodes
rigthnodes <- 1
rightnodes <- 1
leftnodes
leftnodes[-(1:2)]
leftnodes[-(1:2)]-1
ui$nodelist[[length(ui$nodelist)]]
rightnodes <- c(1, leftnodes[-(1:2)]-1, max(ui$nodelist[[length(ui$nodelist)]]))
rightnodes
ui <- gen_tree_structure(500)
# ui$nodelist
leftnodes <- 1
count <- 1
while(leftnodes[count] <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
leftnodes
rightnodes <- c(1, leftnodes[-(1:2)]-1, max(ui$nodelist[[length(ui$nodelist)]]))
leftnodes
rightnodes
ui$leftnodes
ui$rightnodes
leftnodes[length(leftnodes)]
set.seed(123)
ui <- gen_tree_structure(20)
# ui$nodelist
leftnodes <- 1
count <- 1
while(leftnodes[count] <= length(ui$nodelist)) {
leftnodes[count+1] <- ui$nodelist[[leftnodes[count]]][1]
count <- count+1
}
leftnodes
rightnodes <- c(1, leftnodes[-(1:2)]-1, max(ui$nodelist[[length(ui$nodelist)]]))
leftnodes
rightnodes
leftnodes[length(leftnodes)]:rightnodes[length(leftnodes)]
1 + 3.5
300*7*12
300*7*12 - 500*7*3
ui <- "          data_algorithm[[i]] <- data.table::fread(file.path(main_dir,\"output/simulated_data/150100\", str_subset(files_algorithm, paste(algorithm))[[i]]) , stringsAsFactors = FALSE) %>% setNames(.,c(\"elapsed\", paste(algorithm)))"
nchar(ui)
matrix(nrow=n, ncol=7, data=sample(c(0,1), size=n*7, replace=TRUE))
n <- 10
unique(matrix(nrow=n, ncol=7, data=sample(c(0,1), size=n*7, replace=TRUE)))
aha <- unique(matrix(nrow=n, ncol=7, data=sample(c(0,1), size=n*7, replace=TRUE)))
n <- 1000000
aha <- unique(matrix(nrow=n, ncol=7, data=sample(c(0,1), size=n*7, replace=TRUE)))
dim(aha)
2^7
head(aha)
aha2 <- aha[order(aha[,1], aha[,2], aha[,3], aha[,4], aha[,5], aha[,6], aha[,7]),]
head(aha2)
fix(aha2)
nchar("Prediction approaches for partly missing multi-omics covariate data: A literature review and an empirical comparison study")
nchar("Prediction approaches for partly missing multi-omics covariate data")
nchar("Empirical comparison study of approaches for partly missing multi-omics covariate data")
nchar("Existing prediction approaches for partly missing multi-omics covariate data")
nchar("Multi-omics data are high-dimensional molecular data for which several types of omics data (e.g., RNA data) are available for the same patients. A common issue in prediction using multi-omics data is that some of the considered omics data types are only available for subsets of the patients.")
toupper("Existing prediction approaches for partly missing multi-omics covariate data")
toupper("Empirical comparison study of approaches for partly missing multi-omics covariate data")
toupper("Availability of data and materials")
toupper("Acknowledgements")
86/52.1429
86/365
1/(86/365)
1/(69/365)
1/((86+69)/365)
1/((86+69)/2/365)
70/52.1429
uia <- list.files("D:/Projects/SideProjects/BlockwiseMissing/GitHub_Code/bwm_article/compstudy_code_and_results/results/pl_approach")
uia
uia1 <- setdiff(uia, c("PL_Eval_ESCA_2_4_3.csv", "PL_Eval_ESCA_4_4_3.csv", "PL_Eval_ESCA_old.csv", "PL_Eval_PAAD_4_4_5.csv", "PL_Eval_PAAD_old.csv"))
uia2 <- c("PL_Eval_ESCA_2_4_3.csv", "PL_Eval_ESCA_4_4_3.csv", "PL_Eval_ESCA_old.csv", "PL_Eval_PAAD_4_4_5.csv", "PL_Eval_PAAD_old.csv")
uia1
uia2
for(in in seq(along=ui1))
cat(paste(uia, collapse=", "), "\n")
cat(paste(uia2, collapse=", "), "\n")
args <- commandArgs(trailingOnly = TRUE)
args
library(ordinalForest)
install.packages("ordinalForest")
library(ordinalForest)
ls()
rm(list=ls());gc()
load("D:/Projects/SideProjects/Yingxia/Paper/Code/multi-omics-data/Data/datset_ids.RData")
ls()
datset_ids
setwd("D:/Projects/DESTATIS/PredErrorComplex/PPerfEstComplex")
rm(list=ls());gc()
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# Make a list which will contain the coefficients of the simulation models
# and other information:
coeflist <- vector(mode = "list", length = length(treestruc$nodelist))
for(i in seq(along=coeflist)) {
coeflist[[i]] <- list()
# Add the information on the child nodes for each node:
coeflist[[i]][[1]] <- treestruc$nodelist[[i]]
# Add the layer of each node:
coeflist[[i]][[2]] <- which(sapply(1:length(treestruc$leftnodes), function(x) (i >= treestruc$leftnodes[x]) & (i <= treestruc$rightnodes[x])))
names(coeflist[[i]]) <- c("childnodes", "layer")
}
# Simulate the coefficients:
set.seed(1234)
# Variance of the normal distribution from which the intercepts are drawn:
sdbeta0 <- sqrt(1)
# The betas have layer-specific variances:
sdbeta <- sqrt(c(1, 1.5, 2, 2.5))
maxlayer <- max(sapply(coeflist, function(x) x$layer))
for(i in seq(along=coeflist)) {
if(coeflist[[i]]$layer==maxlayer) {
coeflist[[i]]$coefs <- NA
} else {
if(length(coeflist[[i]]$childnodes)==2) {
coefs <- matrix(nrow=1, ncol=6, data=c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
if(length(coeflist[[i]]$childnodes)==3) {
coefs <- rbind(c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])),
c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
coeflist[[i]]$coefs <- coefs
}
}
get_child_nodes <- function(Xsub, coefs) {
desmat <- cbind(1, Xsub)
if (nrow(coefs)==2)
vProb <- cbind(1, exp(desmat%*%coefs[1,]), exp(desmat%*%coefs[2,]))
else
vProb <- cbind(1, exp(desmat%*%coefs[1,]))
mChoices <- t(apply(vProb, 1, rmultinom, n = 1, size = 1))
ys <- apply(mChoices, 1, function(x) which(x==1))
return(ys)
}
# Simulate a whole dataset:
n <- 5000
X <- matrix(nrow=n, ncol=5, rnorm(n*5))
head(coeflist)
source("./simulations/hierpr/functions.R")
plot_structure(treestruc)
ui <- get_child_nodes(X, coeflist[[1]]$coefs)
head(ui)
ui
coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
ui <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
ui2 <- coeflist[[2]]$childnodes[get_child_nodes(X[ui==2,], coeflist[[2]]$coefs)]
table(ui2)
length(ui2)
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
2:maxlayer
1:(maxlayer-1)
sapply(coeflist, function(x) x$childnodes)
sapply(coeflist, function(x) x$childnodes)[sapply(coeflist, function(x) x$layer==5)]
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
head(tempclass)
class(X)
dataset <- data.frame(X)
dim(dataset)
head(dataset)
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
outcomemat <- matrix(nrow=nrow(X), ncol=maxlayer)
outcomemat[,1] <- tempclass
head(outcomemat)
length(coeflist[[1]])
names(coeflist[[1]])
coeflist[[1]][4] <- outcomemat
coeflist[[1]]
#asdf
coeflist[[1]][[4]] <- outcomemat
coeflist[[1]][[4]]$y <- outcomemat[,1]
# Simulate the coefficients:
set.seed(1234)
# Variance of the normal distribution from which the intercepts are drawn:
sdbeta0 <- sqrt(1)
# The betas have layer-specific variances:
sdbeta <- sqrt(c(1, 1.5, 2, 2.5))
maxlayer <- max(sapply(coeflist, function(x) x$layer))
for(i in seq(along=coeflist)) {
if(coeflist[[i]]$layer==maxlayer) {
coeflist[[i]]$coefs <- NA
} else {
if(length(coeflist[[i]]$childnodes)==2) {
coefs <- matrix(nrow=1, ncol=6, data=c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
if(length(coeflist[[i]]$childnodes)==3) {
coefs <- rbind(c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])),
c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
coeflist[[i]]$coefs <- coefs
}
}
# Function that takes the covariate matrix of the subset of observations
# contained in a node and the coefficients associated with that node
# to output the indices of the child nodes to which the observations
# get assigned to.
get_child_nodes <- function(Xsub, coefs) {
desmat <- cbind(1, Xsub)
if (nrow(coefs)==2)
vProb <- cbind(1, exp(desmat%*%coefs[1,]), exp(desmat%*%coefs[2,]))
else
vProb <- cbind(1, exp(desmat%*%coefs[1,]))
mChoices <- t(apply(vProb, 1, rmultinom, n = 1, size = 1))
ys <- apply(mChoices, 1, function(x) which(x==1))
return(ys)
}
# Simulate a whole dataset:
n <- 5000
X <- matrix(nrow=n, ncol=5, rnorm(n*5))
# innerclasses
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
outcomemat[,1] <- tempclass
head(outcomemat)
#asdf
coeflist[[1]]$datanode <- data.frame(X)
coeflist[[1]]$datatnode$y <- outcomemat[,1]
head(coeflist[[1]]$datanode)
coeflist[[1]]$datanode$y <- outcomemat[,1]
head(coeflist[[1]]$datanode)
coeflist[[1]]$datanode$y <- factor(outcomemat[,1])
treestruc$nodelist[[5]]
treestruc$nodelist[[11]]
which(sapply(1:length(coeflist), function(x) 11 %in% coeflist[[x]]$childnodes))
# treestruc
coeflist <- vector(mode = "list", length = length(treestruc$nodelist))
for(i in seq(along=coeflist)) {
coeflist[[i]] <- list()
# Add the information on the child nodes for each node:
coeflist[[i]]$childnodes <- treestruc$nodelist[[i]]
# Add the information on the parent nodes for each node:
coeflist[[i]]$parentnodes <- which(sapply(1:length(coeflist), function(x) i %in% coeflist[[x]]$childnodes))
# Add the layer of each node:
coeflist[[i]]$layer <- which(sapply(1:length(treestruc$leftnodes), function(x) (i >= treestruc$leftnodes[x]) & (i <= treestruc$rightnodes[x])))
}
coeflist
# Simulate the coefficients:
set.seed(1234)
# Variance of the normal distribution from which the intercepts are drawn:
sdbeta0 <- sqrt(1)
# The betas have layer-specific variances:
sdbeta <- sqrt(c(1, 1.5, 2, 2.5))
maxlayer <- max(sapply(coeflist, function(x) x$layer))
for(i in seq(along=coeflist)) {
if(coeflist[[i]]$layer==maxlayer) {
coeflist[[i]]$coefs <- NA
} else {
if(length(coeflist[[i]]$childnodes)==2) {
coefs <- matrix(nrow=1, ncol=6, data=c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
if(length(coeflist[[i]]$childnodes)==3) {
coefs <- rbind(c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])),
c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
coeflist[[i]]$coefs <- coefs
}
}
# Function that takes the covariate matrix of the subset of observations
# contained in a node and the coefficients associated with that node
# to output the indices of the child nodes to which the observations
# get assigned to.
get_child_nodes <- function(Xsub, coefs) {
desmat <- cbind(1, Xsub)
if (nrow(coefs)==2)
vProb <- cbind(1, exp(desmat%*%coefs[1,]), exp(desmat%*%coefs[2,]))
else
vProb <- cbind(1, exp(desmat%*%coefs[1,]))
mChoices <- t(apply(vProb, 1, rmultinom, n = 1, size = 1))
ys <- apply(mChoices, 1, function(x) which(x==1))
return(ys)
}
# Simulate a whole dataset:
n <- 5000
X <- matrix(nrow=n, ncol=5, rnorm(n*5))
# innerclasses
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
outcomemat[,1] <- tempclass
head(outcomemat)
#asdf
coeflist[[1]]$datanode <- data.frame(X)
coeflist[[1]]$datanode$y <- factor(outcomemat[,1])
i <- 2
coeflist[[i]]$layer
tempclass <- coeflist[[2]]$childnodes[get_child_nodes(X[outcomemat[,coeflist[[i]]$layer-1]==i,], coeflist[[i]]$coefs)]
length(tempclass)
i <- 2
tempclass <- coeflist[[2]]$childnodes[get_child_nodes(X[outcomemat[,coeflist[[i]]$layer-1]==i,], coeflist[[i]]$coefs)]
outcomemat[outcomemat[,coeflist[[i]]$layer-1]==i,coeflist[[i]]$layer] <- tempclass
fix(outcomemat)
sum(is.na(outcomemat[,2]))
i <- 2
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
tempclass <- coeflist[[2]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
i <- 2
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
tempclass <- coeflist[[2]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
coeflist[[i]]$datanode <- data.frame(X[subs,])
coeflist[[i]]$datanode$y <- factor(tempclass)
i <- 3
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
tempclass <- coeflist[[2]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
coeflist[[i]]$datanode <- data.frame(X[subs,])
coeflist[[i]]$datanode$y <- factor(tempclass)
fix(outcomemat)
sum(outcomemat[,2] %in% c(7,8))
fix(outcomemat)
i <- 3
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
tempclass <- coeflist[[i]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
coeflist[[i]]$datanode <- data.frame(X[subs,])
coeflist[[i]]$datanode$y <- factor(tempclass)
sum(outcomemat[,2] %in% c(7,8))
i <- 4
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
tempclass <- coeflist[[i]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
coeflist[[i]]$datanode <- data.frame(X[subs,])
coeflist[[i]]$datanode$y <- factor(tempclass)
fix(outcomemat)
# innerclasses
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
outcomemat[,1] <- tempclass
head(outcomemat)
#asdf
coeflist[[1]]$datanode <- data.frame(X)
coeflist[[1]]$datanode$y <- factor(tempclass)
for(i in 2:(length(coeflist)-1)) {
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
tempclass <- coeflist[[i]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
coeflist[[i]]$datanode <- data.frame(X[subs,])
coeflist[[i]]$datanode$y <- factor(tempclass)
}
i
i
get_child_nodes(X[subs,], coeflist[[i]]$coefs
)
dim(X[subs,])
ui <- X[subs,]
coeflist[[i]]$coefs
load("./simulations/hierpr/results/intermediate_results/treestruc.Rda")
# Make a list which will contain the coefficients of the simulation models
# and other information:
# treestruc
coeflist <- vector(mode = "list", length = length(treestruc$nodelist))
for(i in seq(along=coeflist)) {
coeflist[[i]] <- list()
# Add the information on the child nodes for each node:
coeflist[[i]]$childnodes <- treestruc$nodelist[[i]]
# Add the information on the parent nodes for each node:
coeflist[[i]]$parentnodes <- which(sapply(1:length(coeflist), function(x) i %in% coeflist[[x]]$childnodes))
# Add the layer of each node:
coeflist[[i]]$layer <- which(sapply(1:length(treestruc$leftnodes), function(x) (i >= treestruc$leftnodes[x]) & (i <= treestruc$rightnodes[x])))
}
# Simulate the coefficients:
set.seed(1234)
# Variance of the normal distribution from which the intercepts are drawn:
sdbeta0 <- sqrt(1)
# The betas have layer-specific variances:
sdbeta <- sqrt(c(1, 1.5, 2, 2.5))
maxlayer <- max(sapply(coeflist, function(x) x$layer))
for(i in seq(along=coeflist)) {
# if(coeflist[[i]]$layer==maxlayer) {
#   coeflist[[i]]$coefs <- NA
# } else {
if(length(coeflist[[i]]$childnodes)==2) {
coefs <- matrix(nrow=1, ncol=6, data=c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
if(length(coeflist[[i]]$childnodes)==3) {
coefs <- rbind(c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])),
c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
coeflist[[i]]$coefs <- coefs
# }
}
warnings()
# Simulate the coefficients:
set.seed(1234)
# Variance of the normal distribution from which the intercepts are drawn:
sdbeta0 <- sqrt(1)
# The betas have layer-specific variances:
sdbeta <- sqrt(c(1, 1.5, 2, 2.5, 3))
maxlayer <- max(sapply(coeflist, function(x) x$layer))
for(i in seq(along=coeflist)) {
# if(coeflist[[i]]$layer==maxlayer) {
#   coeflist[[i]]$coefs <- NA
# } else {
if(length(coeflist[[i]]$childnodes)==2) {
coefs <- matrix(nrow=1, ncol=6, data=c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
if(length(coeflist[[i]]$childnodes)==3) {
coefs <- rbind(c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])),
c(rnorm(1, sd=sdbeta0), rnorm(5, sd=sdbeta[coeflist[[i]]$layer])))
}
coeflist[[i]]$coefs <- coefs
# }
}
# Simulate a whole dataset:
n <- 5000
X <- matrix(nrow=n, ncol=5, rnorm(n*5))
# innerclasses
tempclass <- coeflist[[1]]$childnodes[get_child_nodes(X, coeflist[[1]]$coefs)]
outcomemat[,1] <- tempclass
head(outcomemat)
#asdf
coeflist[[1]]$datanode <- data.frame(X)
coeflist[[1]]$datanode$y <- factor(tempclass)
#asdf
for(i in 2:(length(coeflist)-1)) {
subs <- outcomemat[,coeflist[[i]]$layer-1]==i
tempclass <- coeflist[[i]]$childnodes[get_child_nodes(X[subs,], coeflist[[i]]$coefs)]
outcomemat[subs,coeflist[[i]]$layer] <- tempclass
coeflist[[i]]$datanode <- data.frame(X[subs,])
coeflist[[i]]$datanode$y <- factor(tempclass)
}
fix(outcomemat)
table(outcomemat[,5])
length(table(outcomemat[,5]))
barplot(table(outcomemat[,5]))
